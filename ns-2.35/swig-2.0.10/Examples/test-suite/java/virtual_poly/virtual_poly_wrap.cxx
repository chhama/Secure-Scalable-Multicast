/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.10
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGJAVA
#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
  typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
# ifdef _LP64
#   undef _LP64
# endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1, 
  SWIG_JavaIOException, 
  SWIG_JavaRuntimeException, 
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" }
  };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  jenv->ExceptionClear();
  excep = jenv->FindClass(except_ptr->java_exception);
  if (excep)
    jenv->ThrowNew(excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else

/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes that proxy
 * method calls from C++ to Java extensions.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus

#if defined(DEBUG_DIRECTOR_OWNED)
#include <iostream>
#endif

namespace Swig {
  /* Java object wrapper */
  class JObjectWrapper {
  public:
    JObjectWrapper() : jthis_(NULL), weak_global_(true) {
    }

    ~JObjectWrapper() {
      jthis_ = NULL;
      weak_global_ = true;
    }

    bool set(JNIEnv *jenv, jobject jobj, bool mem_own, bool weak_global) {
      if (!jthis_) {
        weak_global_ = weak_global || !mem_own; // hold as weak global if explicitly requested or not owned
        if (jobj)
          jthis_ = weak_global_ ? jenv->NewWeakGlobalRef(jobj) : jenv->NewGlobalRef(jobj);
#if defined(DEBUG_DIRECTOR_OWNED)
        std::cout << "JObjectWrapper::set(" << jobj << ", " << (weak_global ? "weak_global" : "global_ref") << ") -> " << jthis_ << std::endl;
#endif
        return true;
      } else {
#if defined(DEBUG_DIRECTOR_OWNED)
        std::cout << "JObjectWrapper::set(" << jobj << ", " << (weak_global ? "weak_global" : "global_ref") << ") -> already set" << std::endl;
#endif
        return false;
      }
    }

    jobject get(JNIEnv *jenv) const {
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "JObjectWrapper::get(";
      if (jthis_)
        std::cout << jthis_;
      else
        std::cout << "null";
      std::cout << ") -> return new local ref" << std::endl;
#endif
      return (jthis_ ? jenv->NewLocalRef(jthis_) : jthis_);
    }

    void release(JNIEnv *jenv) {
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "JObjectWrapper::release(" << jthis_ << "): " << (weak_global_ ? "weak global ref" : "global ref") << std::endl;
#endif
      if (jthis_) {
        if (weak_global_) {
          if (jenv->IsSameObject(jthis_, NULL) == JNI_FALSE)
            jenv->DeleteWeakGlobalRef((jweak)jthis_);
        } else
          jenv->DeleteGlobalRef(jthis_);
      }

      jthis_ = NULL;
      weak_global_ = true;
    }

    /* Only call peek if you know what you are doing wrt to weak/global references */
    jobject peek() {
      return jthis_;
    }

    /* Java proxy releases ownership of C++ object, C++ object is now
       responsible for destruction (creates NewGlobalRef to pin Java
       proxy) */
    void java_change_ownership(JNIEnv *jenv, jobject jself, bool take_or_release) {
      if (take_or_release) {  /* Java takes ownership of C++ object's lifetime. */
        if (!weak_global_) {
          jenv->DeleteGlobalRef(jthis_);
          jthis_ = jenv->NewWeakGlobalRef(jself);
          weak_global_ = true;
        }
      } else { /* Java releases ownership of C++ object's lifetime */
        if (weak_global_) {
          jenv->DeleteWeakGlobalRef((jweak)jthis_);
          jthis_ = jenv->NewGlobalRef(jself);
          weak_global_ = false;
        }
      }
    }

  private:
    /* pointer to Java object */
    jobject jthis_;
    /* Local or global reference flag */
    bool weak_global_;
  };

  /* director base class */
  class Director {
    /* pointer to Java virtual machine */
    JavaVM *swig_jvm_;

  protected:
#if defined (_MSC_VER) && (_MSC_VER<1300)
    class JNIEnvWrapper;
    friend class JNIEnvWrapper;
#endif
    /* Utility class for managing the JNI environment */
    class JNIEnvWrapper {
      const Director *director_;
      JNIEnv *jenv_;
      int env_status;
    public:
      JNIEnvWrapper(const Director *director) : director_(director), jenv_(0), env_status(0) {
#if defined(__ANDROID__)
        JNIEnv **jenv = &jenv_;
#else
        void **jenv = (void **)&jenv_;
#endif
        env_status = director_->swig_jvm_->GetEnv((void **)&jenv_, JNI_VERSION_1_2);
#if defined(SWIG_JAVA_ATTACH_CURRENT_THREAD_AS_DAEMON)
        // Attach a daemon thread to the JVM. Useful when the JVM should not wait for 
        // the thread to exit upon shutdown. Only for jdk-1.4 and later.
        director_->swig_jvm_->AttachCurrentThreadAsDaemon(jenv, NULL);
#else
        director_->swig_jvm_->AttachCurrentThread(jenv, NULL);
#endif
      }
      ~JNIEnvWrapper() {
#if !defined(SWIG_JAVA_NO_DETACH_CURRENT_THREAD)
        // Some JVMs, eg jdk-1.4.2 and lower on Solaris have a bug and crash with the DetachCurrentThread call.
        // However, without this call, the JVM hangs on exit when the thread was not created by the JVM and creates a memory leak.
        if (env_status == JNI_EDETACHED)
          director_->swig_jvm_->DetachCurrentThread();
#endif
      }
      JNIEnv *getJNIEnv() const {
        return jenv_;
      }
    };

    /* Java object wrapper */
    JObjectWrapper swig_self_;

    /* Disconnect director from Java object */
    void swig_disconnect_director_self(const char *disconn_method) {
      JNIEnvWrapper jnienv(this) ;
      JNIEnv *jenv = jnienv.getJNIEnv() ;
      jobject jobj = swig_self_.get(jenv);
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "Swig::Director::disconnect_director_self(" << jobj << ")" << std::endl;
#endif
      if (jobj && jenv->IsSameObject(jobj, NULL) == JNI_FALSE) {
        jmethodID disconn_meth = jenv->GetMethodID(jenv->GetObjectClass(jobj), disconn_method, "()V");
        if (disconn_meth) {
#if defined(DEBUG_DIRECTOR_OWNED)
          std::cout << "Swig::Director::disconnect_director_self upcall to " << disconn_method << std::endl;
#endif
          jenv->CallVoidMethod(jobj, disconn_meth);
        }
      }
      jenv->DeleteLocalRef(jobj);
    }

  public:
    Director(JNIEnv *jenv) : swig_jvm_((JavaVM *) NULL), swig_self_() {
      /* Acquire the Java VM pointer */
      jenv->GetJavaVM(&swig_jvm_);
    }

    virtual ~Director() {
      JNIEnvWrapper jnienv(this) ;
      JNIEnv *jenv = jnienv.getJNIEnv() ;
      swig_self_.release(jenv);
    }

    bool swig_set_self(JNIEnv *jenv, jobject jself, bool mem_own, bool weak_global) {
      return swig_self_.set(jenv, jself, mem_own, weak_global);
    }

    jobject swig_get_self(JNIEnv *jenv) const {
      return swig_self_.get(jenv);
    }

    // Change C++ object's ownership, relative to Java
    void swig_java_change_ownership(JNIEnv *jenv, jobject jself, bool take_or_release) {
      swig_self_.java_change_ownership(jenv, jself, take_or_release);
    }
  };
}

#endif /* __cplusplus */



#if defined(__SUNPRO_CC)
#pragma error_messages (off, wbadasg) /* Assigning extern "C" ... */
#endif

  
  struct NNumber
  {
    virtual ~NNumber() {};
    virtual NNumber* copy() const = 0;
    virtual NNumber& ref_this() 
    {
      return *this;
    }
    
    
    NNumber* nnumber() 
    {
      return this;
    }
    

  };
  
  /* 
     NInt and NDouble are both NNumber derived classes, but they
     have more different than common attributes.
     
     In particular the function 'get', that is type dependent, can't
     be included in the NNumber abstract interface.

     For this reason, the virtual 'copy' method has a polymorphic (covariant)
     return type, since in most of the cases we don't want to lose the
     original object type, which is very very important.

     Using the polymorphic return type reduced greatly the need of
     using 'dynamic_cast' at the C++ side, and at the target languages
     that support it.
   */
  struct NInt : NNumber
  {
    NInt(int v) : val(v) 
    {
    }
    
    int get() const
    {
      return val;
    }
    
    virtual NInt* copy() const
    {
      return new NInt(val);
    }

    virtual NInt& ref_this() 
    {
      return *this;
    }

    /* See below */
    static NInt* narrow(NNumber* nn);

    
  private:
    int val;
  };

  inline NInt& incr(NInt& i) {
    i = i.get() + 1;
    return i;
  }

  struct NDouble : NNumber
  {
    NDouble(double v) : val(v) 
    {
    }
    
    double get() const
    {
      return val;
    }
    
    virtual NDouble* copy() const
    {
      return new NDouble(val);
    }

    virtual NDouble& ref_this() 
    {
      return *this;
    }

    /* See below */
    static NDouble* narrow(NNumber* nn);
    
  private:
    double val;
  };

  /*
     Java and C# do not support the polymorphic (covariant) return types used
     in the copy method. So, they just emit 'plain' copy functions as if this is
     being wrapped instead:
    
      NNumber* NNumber::copy() const;
      NNumber* NInt::copy() const;  
      NNumber* NDouble::copy() const;
    
     However, since the objects provide their own downcasting
     mechanism, the narrow methods similar to the CORBA mechanism,
     could be used, otherwise use the Java/C# downcasts.
  */
  inline NInt* NInt::narrow(NNumber* n) {
    // this is just a plain C++ dynamic_cast, but in theory the user
    // could use whatever he wants.
    return dynamic_cast<NInt*>(n);
  }  
  
  inline NDouble* NDouble::narrow(NNumber* n) {
    return dynamic_cast<NDouble*>(n);
  }



// These three classes test covariant return types and whether swig accurately matches
// polymorphic methods (mainly for C# override keyword). Also tests methods which hide
// the base class' method (for C#, new keyword required on method declaration).

typedef int* IntegerPtr;
typedef double Double;

template<typename T> struct Base {
  T t;
  virtual IntegerPtr method() const = 0;
  virtual IntegerPtr foxy() const = 0;
  virtual IntegerPtr foxy(int a) const = 0;
  virtual int * foxy(int*& a) { return 0; }
  virtual double afunction() = 0;
  virtual IntegerPtr defaultargs(double d, int * a = 0) = 0;
  static void StaticHidden() {}
  void AmIAmINotVirtual() {}
  IntegerPtr NotVirtual(IntegerPtr i) { return 0; }
  virtual Base * covariant(int a = 0, int * i = 0) { return 0; }
  typedef Base * BasePtr;
  virtual BasePtr covariant2() { return 0; }
  virtual BasePtr covariant3() { return 0; }
  virtual ~Base() {}
};

template<typename T> struct Derived : Base<T> {
  int * method() const { return 0; }
  IntegerPtr foxy() const { return 0; }
  int * foxy(int a) const { return 0; }
  virtual int * foxy(int*& a) { return 0; }
  Double afunction() { return 0; }
  int * defaultargs(Double d, IntegerPtr a = 0) { return 0; }
  void AmIAmINotVirtual() {}
  int * NotVirtual(int *i) { return 0; }
  typedef Derived * DerivedPtr;
  DerivedPtr covariant(int a = 0, IntegerPtr i = 0) { return 0; }
  DerivedPtr covariant2() { return 0; }
  Derived<T> * covariant3() { return 0; }
  virtual Derived<T> * covariant4(double d) { return 0; }
  virtual int IsVirtual() { return 0; }
};

template<typename T> struct Bottom : Derived<T> {
  int * method() const { return 0; }
  static void StaticHidden() {}
  void AmIAmINotVirtual() {}
  IntegerPtr NotVirtual(IntegerPtr i) { return 0; }
  void (*funcptr)(int a, bool b);
  Bottom<T> * covariant(int a = 0, IntegerPtr i = 0) { return 0; }
  Derived<T> * covariant2() { return 0; }
  Bottom<T> * covariant3() { return 0; }
  Bottom<T> * covariant4(double d) { return 0; }
  int IsVirtual() { return 0; }
};



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "virtual_poly_wrap.h"


#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_delete_1NNumber(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  NNumber *arg1 = (NNumber *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(NNumber **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NNumber_1copy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NNumber *arg1 = (NNumber *) 0 ;
  NNumber *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NNumber **)&jarg1; 
  result = (NNumber *)((NNumber const *)arg1)->copy();
  *(NNumber **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NNumber_1ref_1this(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NNumber *arg1 = (NNumber *) 0 ;
  NNumber *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NNumber **)&jarg1; 
  result = (NNumber *) &(arg1)->ref_this();
  *(NNumber **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NNumber_1nnumber(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NNumber *arg1 = (NNumber *) 0 ;
  NNumber *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NNumber **)&jarg1; 
  result = (NNumber *)(arg1)->nnumber();
  *(NNumber **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_new_1NInt(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int arg1 ;
  NInt *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (NInt *)new NInt(arg1);
  *(NInt **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_virtual_1poly_virtual_1polyJNI_NInt_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  NInt *arg1 = (NInt *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NInt **)&jarg1; 
  result = (int)((NInt const *)arg1)->get();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NInt_1copy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NInt *arg1 = (NInt *) 0 ;
  NInt *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NInt **)&jarg1; 
  result = (NInt *)((NInt const *)arg1)->copy();
  *(NInt **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NInt_1ref_1this(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NInt *arg1 = (NInt *) 0 ;
  NInt *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NInt **)&jarg1; 
  result = (NInt *) &(arg1)->ref_this();
  *(NInt **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NInt_1narrow(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NNumber *arg1 = (NNumber *) 0 ;
  NInt *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NNumber **)&jarg1; 
  result = (NInt *)NInt::narrow(arg1);
  *(NInt **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_delete_1NInt(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  NInt *arg1 = (NInt *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(NInt **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_incr(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NInt *arg1 = 0 ;
  NInt *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NInt **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "NInt & reference is null");
    return 0;
  } 
  result = (NInt *) &incr(*arg1);
  *(NInt **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_new_1NDouble(JNIEnv *jenv, jclass jcls, jdouble jarg1) {
  jlong jresult = 0 ;
  double arg1 ;
  NDouble *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (double)jarg1; 
  result = (NDouble *)new NDouble(arg1);
  *(NDouble **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_virtual_1poly_virtual_1polyJNI_NDouble_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  NDouble *arg1 = (NDouble *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NDouble **)&jarg1; 
  result = (double)((NDouble const *)arg1)->get();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NDouble_1copy(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NDouble *arg1 = (NDouble *) 0 ;
  NDouble *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NDouble **)&jarg1; 
  result = (NDouble *)((NDouble const *)arg1)->copy();
  *(NDouble **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NDouble_1ref_1this(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NDouble *arg1 = (NDouble *) 0 ;
  NDouble *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NDouble **)&jarg1; 
  result = (NDouble *) &(arg1)->ref_this();
  *(NDouble **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NDouble_1narrow(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  NNumber *arg1 = (NNumber *) 0 ;
  NDouble *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(NNumber **)&jarg1; 
  result = (NDouble *)NDouble::narrow(arg1);
  *(NDouble **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_delete_1NDouble(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  NDouble *arg1 = (NDouble *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(NDouble **)&jarg1; 
  delete arg1;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1t_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  Base< int > *arg1 = (Base< int > *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->t = arg2;
}


SWIGEXPORT jint JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1t_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  result = (int) ((arg1)->t);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1method(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  IntegerPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  result = (IntegerPtr)((Base< int > const *)arg1)->method();
  *(IntegerPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1foxy_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  IntegerPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  result = (IntegerPtr)((Base< int > const *)arg1)->foxy();
  *(IntegerPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1foxy_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  int arg2 ;
  IntegerPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (IntegerPtr)((Base< int > const *)arg1)->foxy(arg2);
  *(IntegerPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1foxy_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  int **arg2 = 0 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  arg2 = *(int ***)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int *& reference is null");
    return 0;
  } 
  result = (int *)(arg1)->foxy(*arg2);
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1afunction(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  result = (double)(arg1)->afunction();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1defaultargs_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2, jlong jarg3) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  double arg2 ;
  int *arg3 = (int *) 0 ;
  IntegerPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  arg2 = (double)jarg2; 
  arg3 = *(int **)&jarg3; 
  result = (IntegerPtr)(arg1)->defaultargs(arg2,arg3);
  *(IntegerPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1defaultargs_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  double arg2 ;
  IntegerPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  arg2 = (double)jarg2; 
  result = (IntegerPtr)(arg1)->defaultargs(arg2);
  *(IntegerPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1StaticHidden(JNIEnv *jenv, jclass jcls) {
  (void)jenv;
  (void)jcls;
  Base< int >::SWIGTEMPLATEDISAMBIGUATOR StaticHidden();
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1AmIAmINotVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  Base< int > *arg1 = (Base< int > *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  (arg1)->AmIAmINotVirtual();
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1NotVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  IntegerPtr arg2 = (IntegerPtr) 0 ;
  IntegerPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  arg2 = *(IntegerPtr *)&jarg2; 
  result = (IntegerPtr)(arg1)->NotVirtual(arg2);
  *(IntegerPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1covariant_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  Base< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = *(int **)&jarg3; 
  result = (Base< int > *)(arg1)->covariant(arg2,arg3);
  *(Base< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1covariant_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  int arg2 ;
  Base< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (Base< int > *)(arg1)->covariant(arg2);
  *(Base< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1covariant_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  Base< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  result = (Base< int > *)(arg1)->covariant();
  *(Base< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1covariant2(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  Base< int >::BasePtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  result = (Base< int >::BasePtr)(arg1)->covariant2();
  *(Base< int >::BasePtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BaseInt_1covariant3(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Base< int > *arg1 = (Base< int > *) 0 ;
  Base< int >::BasePtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Base< int > **)&jarg1; 
  result = (Base< int >::BasePtr)(arg1)->covariant3();
  *(Base< int >::BasePtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_delete_1BaseInt(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  Base< int > *arg1 = (Base< int > *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(Base< int > **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1method(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  result = (int *)((Derived< int > const *)arg1)->method();
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1foxy_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  IntegerPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  result = (IntegerPtr)((Derived< int > const *)arg1)->foxy();
  *(IntegerPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1foxy_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  int arg2 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (int *)((Derived< int > const *)arg1)->foxy(arg2);
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1foxy_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  int **arg2 = 0 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  arg2 = *(int ***)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "int *& reference is null");
    return 0;
  } 
  result = (int *)(arg1)->foxy(*arg2);
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1afunction(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  Double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  result = (Double)(arg1)->afunction();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1defaultargs_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2, jlong jarg3) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  Double arg2 ;
  IntegerPtr arg3 = (IntegerPtr) 0 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  arg2 = (Double)jarg2; 
  arg3 = *(IntegerPtr *)&jarg3; 
  result = (int *)(arg1)->defaultargs(arg2,arg3);
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1defaultargs_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  Double arg2 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  arg2 = (Double)jarg2; 
  result = (int *)(arg1)->defaultargs(arg2);
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1AmIAmINotVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  (arg1)->AmIAmINotVirtual();
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1NotVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  int *arg2 = (int *) 0 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  arg2 = *(int **)&jarg2; 
  result = (int *)(arg1)->NotVirtual(arg2);
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1covariant_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  int arg2 ;
  IntegerPtr arg3 = (IntegerPtr) 0 ;
  Derived< int >::DerivedPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = *(IntegerPtr *)&jarg3; 
  result = (Derived< int >::DerivedPtr)(arg1)->covariant(arg2,arg3);
  *(Derived< int >::DerivedPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1covariant_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  int arg2 ;
  Derived< int >::DerivedPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (Derived< int >::DerivedPtr)(arg1)->covariant(arg2);
  *(Derived< int >::DerivedPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1covariant_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  Derived< int >::DerivedPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  result = (Derived< int >::DerivedPtr)(arg1)->covariant();
  *(Derived< int >::DerivedPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1covariant2(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  Derived< int >::DerivedPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  result = (Derived< int >::DerivedPtr)(arg1)->covariant2();
  *(Derived< int >::DerivedPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1covariant3(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  Derived< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  result = (Derived< int > *)(arg1)->covariant3();
  *(Derived< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1covariant4(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  jlong jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  double arg2 ;
  Derived< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  arg2 = (double)jarg2; 
  result = (Derived< int > *)(arg1)->covariant4(arg2);
  *(Derived< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1IsVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Derived< int > **)&jarg1; 
  result = (int)(arg1)->IsVirtual();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_new_1DerivedInt(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  Derived< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (Derived< int > *)new Derived< int >();
  *(Derived< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_delete_1DerivedInt(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  Derived< int > *arg1 = (Derived< int > *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(Derived< int > **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1method(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  result = (int *)((Bottom< int > const *)arg1)->method();
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1StaticHidden(JNIEnv *jenv, jclass jcls) {
  (void)jenv;
  (void)jcls;
  Bottom< int >::SWIGTEMPLATEDISAMBIGUATOR StaticHidden();
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1AmIAmINotVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  (arg1)->AmIAmINotVirtual();
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1NotVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  IntegerPtr arg2 = (IntegerPtr) 0 ;
  IntegerPtr result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  arg2 = *(IntegerPtr *)&jarg2; 
  result = (IntegerPtr)(arg1)->NotVirtual(arg2);
  *(IntegerPtr *)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1funcptr_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  void (*arg2)(int,bool) = (void (*)(int,bool)) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  arg2 = *(void (**)(int,bool))&jarg2; 
  if (arg1) (arg1)->funcptr = arg2;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1funcptr_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  void (*result)(int,bool) = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  result = (void (*)(int,bool)) ((arg1)->funcptr);
  *(void (**)(int,bool))&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1covariant_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jlong jarg3) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  int arg2 ;
  IntegerPtr arg3 = (IntegerPtr) 0 ;
  Bottom< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = *(IntegerPtr *)&jarg3; 
  result = (Bottom< int > *)(arg1)->covariant(arg2,arg3);
  *(Bottom< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1covariant_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  int arg2 ;
  Bottom< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (Bottom< int > *)(arg1)->covariant(arg2);
  *(Bottom< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1covariant_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  Bottom< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  result = (Bottom< int > *)(arg1)->covariant();
  *(Bottom< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1covariant2(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  Derived< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  result = (Derived< int > *)(arg1)->covariant2();
  *(Derived< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1covariant3(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  Bottom< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  result = (Bottom< int > *)(arg1)->covariant3();
  *(Bottom< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1covariant4(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jdouble jarg2) {
  jlong jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  double arg2 ;
  Bottom< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  arg2 = (double)jarg2; 
  result = (Bottom< int > *)(arg1)->covariant4(arg2);
  *(Bottom< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1IsVirtual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Bottom< int > **)&jarg1; 
  result = (int)(arg1)->IsVirtual();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_new_1BottomInt(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  Bottom< int > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (Bottom< int > *)new Bottom< int >();
  *(Bottom< int > **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_virtual_1poly_virtual_1polyJNI_delete_1BottomInt(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  Bottom< int > *arg1 = (Bottom< int > *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(Bottom< int > **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NInt_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(NNumber **)&baseptr = *(NInt **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_NDouble_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(NNumber **)&baseptr = *(NDouble **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_DerivedInt_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(Base< int > **)&baseptr = *(Derived< int > **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_virtual_1poly_virtual_1polyJNI_BottomInt_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(Derived< int > **)&baseptr = *(Bottom< int > **)&jarg1;
    return baseptr;
}

#ifdef __cplusplus
}
#endif

