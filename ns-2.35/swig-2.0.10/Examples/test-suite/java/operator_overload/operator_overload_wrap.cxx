/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.10
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGJAVA


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
  typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
# ifdef _LP64
#   undef _LP64
# endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1, 
  SWIG_JavaIOException, 
  SWIG_JavaRuntimeException, 
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" }
  };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  jenv->ExceptionClear();
  excep = jenv->FindClass(except_ptr->java_exception);
  if (excep)
    jenv->ThrowNew(excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else



#if defined(_MSC_VER)
  #include <iso646.h> /* for named logical operator, eg 'operator or' */
#endif

#include <assert.h>

class Op {
public:
  int i;
  Op(int a=0) : i(a)
  {}
  Op(const Op& o) : i(o.i)
  {}
  virtual ~Op()
  {}

  friend Op operator &&(const Op& a,const Op& b){return Op(a.i&&b.i);}
  friend Op operator or(const Op& a,const Op& b){return Op(a.i||b.i);}

  Op &operator=(const Op& o) {
    i=o.i;
    return *this;
  }
  // +=,-=... are member fns
  void operator+=(const Op& o){ i+=o.i;}
  void operator-=(const Op& o){ i-=o.i;}
  void operator*=(const Op& o){ i*=o.i;}
  void operator/=(const Op& o){ i/=o.i;}
  void operator%=(const Op& o){ i%=o.i;}
  // the +,-,*,... are friends
  // (just to make life harder)
  friend Op operator+(const Op& a,const Op& b){return Op(a.i+b.i);}
  friend Op operator-(const Op& a,const Op& b);
  friend Op operator*(const Op& a,const Op& b){return Op(a.i*b.i);}
  friend Op operator/(const Op& a,const Op& b){return Op(a.i/b.i);}
  friend Op operator%(const Op& a,const Op& b){return Op(a.i%b.i);}

  // unary operators
  Op operator-() const {return Op(-i);}
  bool operator !() const {return !(i);}

  // overloading the [] operator
  // need 2 versions: get & set
  // note: C++ can be a little mixed up upon which version it calls
  // most of the time it calls the second version
  int operator[](unsigned idx)const
  {	  if (idx==0) return i; return 0;}
  int& operator[](unsigned idx)
  {	  if (idx==0) return i; static int j;j=0; return j;}

  // overloading the () operator
  // this can have many parameters so we will test this
  int operator()(int a=0){return i+a;}
  int operator()(int a,int b){return i+a+b;}

  // increment/decrement operators
  Op& operator++() {++i; return *this;} // prefix ++
  Op operator++(int) {Op o = *this; ++(*this); return o;} // postfix ++
  Op& operator--() {--i; return *this;} // prefix --
  Op operator--(int) {Op o = *this; --(*this); return o;} // postfix --

  // TODO: <<,<<=

  // cast operators
  operator double() { return i; }
  virtual operator int() { return i; }

  // This method just checks that the operators are implemented correctly
  static void sanity_check();
};

// just to complicate matters
// we have a couple of non class operators
inline bool operator==(const Op& a,const Op& b){return a.i==b.i;}
inline bool operator!=(const Op& a,const Op& b){return a.i!=b.i;}
inline bool operator< (const Op& a,const Op& b){return a.i<b.i;}
inline bool operator<=(const Op& a,const Op& b){return a.i<=b.i;}
inline bool operator> (const Op& a,const Op& b){return a.i>b.i;}
inline bool operator>=(const Op& a,const Op& b){return a.i>=b.i;}


SWIGINTERN Op Op_operator_SA__SA_(Op *self,Op const &b){return Op(self->i&&b.i);}
SWIGINTERN Op Op_operator_SS_or(Op *self,Op const &b){return Op(self->i||b.i);}
SWIGINTERN Op Op_operator_Sa_(Op *self,Op const &b){return Op(self->i+b.i);}
SWIGINTERN Op Op_operator_Ss___SWIG_1(Op *self,Op const &b){return Op(self->i-b.i);}
SWIGINTERN Op Op_operator_Sm_(Op *self,Op const &b){return Op(self->i*b.i);}
SWIGINTERN Op Op_operator_Sd_(Op *self,Op const &b){return Op(self->i/b.i);}
SWIGINTERN Op Op_operator_SM_(Op *self,Op const &b){return Op(self->i%b.i);}
SWIGINTERN bool Op_operator_Se__Se_(Op *self,Op const &b){return self->i==b.i;}
SWIGINTERN bool Op_operator_SN__Se_(Op *self,Op const &b){return self->i!=b.i;}
SWIGINTERN bool Op_operator_Sl_(Op *self,Op const &b){return self->i<b.i;}
SWIGINTERN bool Op_operator_Sl__Se_(Op *self,Op const &b){return self->i<=b.i;}
SWIGINTERN bool Op_operator_Sg_(Op *self,Op const &b){return self->i>b.i;}
SWIGINTERN bool Op_operator_Sg__Se_(Op *self,Op const &b){return self->i>=b.i;}
SWIGINTERN Op Op___rsub__(Op *self,int const b){return Op(b - self->i);}
SWIGINTERN char const *Op___str__(Op *self){
		static char buffer[255];
		sprintf(buffer,"Op(%d)",self->i);
		return buffer;
	}
SWIGINTERN int Op___getitem__(Op *self,unsigned int i){	return (*self)[i];	}
SWIGINTERN void Op___setitem__(Op *self,unsigned int i,int v){	(*self)[i]=v;	}

  // This one is not declared inline as VC++7.1 gets mixed up with the unary operator-
  Op operator-(const Op& a,const Op& b){return Op(a.i-b.i);}


class OpDerived : public Op {
public:
  OpDerived(int a=0) : Op(a)
  {}

  // overloaded
  virtual operator int() { return i*2; }
};



#include <assert.h>

void Op::sanity_check()
{
	// test routine:
	Op a;
	Op b=5;
	Op c=b;	// copy construct
	Op d=2;
        Op dd=d; // assignment operator

	// test equality
	assert(a!=b);
	assert(b==c);
	assert(a!=d);
        assert(d==dd);

	// test <
	assert(a<b);
	assert(a<=b);
	assert(b<=c);
	assert(b>=c);
	assert(b>d);
	assert(b>=d);

	// test +=
	Op e=3;
	e+=d;
	assert(e==b);
	e-=c;
	assert(e==a);
	e=Op(1);
	e*=b;
	assert(e==c);
	e/=d;
	assert(e==d);
	e%=c;
	assert(e==d);

	// test +
	Op f(1),g(1);
	assert(f+g==Op(2));
	assert(f-g==Op(0));
	assert(f*g==Op(1));
	assert(f/g==Op(1));
	assert(f%g==Op(0));

	// test unary operators
	assert(!a==true);
	assert(!b==false);
	assert(-a==a);
	assert(-b==Op(-5));

	// test []
	Op h=3;
	assert(h[0]==3);
	assert(h[1]==0);
	h[0]=2;	// set
	assert(h[0]==2);
	h[1]=2;	// ignored
	assert(h[0]==2);
	assert(h[1]==0);

	// test ()
	Op i=3;
	assert(i()==3);
	assert(i(1)==4);
	assert(i(1,2)==6);

	// plus add some code to check the __str__ fn
	//assert(str(Op(1))=="Op(1)");
	//assert(str(Op(-3))=="Op(-3)");

        // test ++ and --
        Op j(100);
        int original = j.i;
        {
          Op newOp = j++;
          int newInt = original++;
          assert(j.i == original);
          assert(newOp.i == newInt);
        }
        {
          Op newOp = j--;
          int newInt = original--;
          assert(j.i == original);
          assert(newOp.i == newInt);
        }
        {
          Op newOp = ++j;
          int newInt = ++original;
          assert(j.i == original);
          assert(newOp.i == newInt);
        }
        {
          Op newOp = --j;
          int newInt = --original;
          assert(j.i == original);
          assert(newOp.i == newInt);
        }

        // cast operators
        Op k=3;
        int check_k = k;
        assert (check_k == 3);

        Op l=4;
        double check_l = l;
        assert (check_l == 4);
}



#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1i_1set(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  Op *arg1 = (Op *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (int)jarg2; 
  if (arg1) (arg1)->i = arg2;
}


SWIGEXPORT jint JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1i_1get(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = (int) ((arg1)->i);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_new_1Op_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int arg1 ;
  Op *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (Op *)new Op(arg1);
  *(Op **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_new_1Op_1_1SWIG_11(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  Op *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (Op *)new Op();
  *(Op **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_new_1Op_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Op *arg1 = 0 ;
  Op *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (Op *)new Op((Op const &)*arg1);
  *(Op **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_delete_1Op(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  Op *arg1 = (Op *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(Op **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_And(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = operator &&((Op const &)*arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Or(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = operator or((Op const &)*arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Equal(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  Op *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (Op *) &(arg1)->operator =((Op const &)*arg2);
  *(Op **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1PlusEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return ;
  } 
  (arg1)->operator +=((Op const &)*arg2);
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1MinusEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return ;
  } 
  (arg1)->operator -=((Op const &)*arg2);
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1MultiplyEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return ;
  } 
  (arg1)->operator *=((Op const &)*arg2);
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1DivideEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return ;
  } 
  (arg1)->operator /=((Op const &)*arg2);
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1PercentEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return ;
  } 
  (arg1)->operator %=((Op const &)*arg2);
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Plus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = operator +((Op const &)*arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Minus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = operator -((Op const &)*arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Multiply(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = operator *((Op const &)*arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Divide(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = operator /((Op const &)*arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Percent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = operator %((Op const &)*arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Minus_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = ((Op const *)arg1)->operator -();
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Not(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jboolean jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = (bool)((Op const *)arg1)->operator !();
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1IndexIntoConst(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jint jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  unsigned int arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (int)((Op const *)arg1)->operator [](arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1IndexInto(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  unsigned int arg2 ;
  int *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (int *) &(arg1)->operator [](arg2);
  *(int **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Functor_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  int arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (int)(arg1)->operator ()(arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Functor_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = (int)(arg1)->operator ()();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Functor_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jint jarg3) {
  jint jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (int)jarg2; 
  arg3 = (int)jarg3; 
  result = (int)(arg1)->operator ()(arg2,arg3);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1PlusPlusPrefix(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = (Op *) &(arg1)->operator ++();
  *(Op **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1PlusPlusPostfix(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  int arg2 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->operator ++(arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1MinusMinusPrefix(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = (Op *) &(arg1)->operator --();
  *(Op **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1MinusMinusPostfix(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  int arg2 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (int)jarg2; 
  result = (arg1)->operator --(arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1DoubleCast(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jdouble jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = (double)(arg1)->operator double();
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1IntCast(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = (int)(arg1)->operator int();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1sanity_1check(JNIEnv *jenv, jclass jcls) {
  (void)jenv;
  (void)jcls;
  Op::sanity_check();
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1And(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = Op_operator_SA__SA_(arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Or(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = Op_operator_SS_or(arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Plus(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = Op_operator_Sa_(arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Minus_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = Op_operator_Ss___SWIG_1(arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Multiply(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = Op_operator_Sm_(arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Divide(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = Op_operator_Sd_(arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1Percent(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = Op_operator_SM_(arg1,(Op const &)*arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1EqualEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)Op_operator_Se__Se_(arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1NotEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)Op_operator_SN__Se_(arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1LessThan(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)Op_operator_Sl_(arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1LessThanEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)Op_operator_Sl__Se_(arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1GreaterThan(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)Op_operator_Sg_(arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1GreaterThanEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1; 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)Op_operator_Sg__Se_(arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1_1_1rsub_1_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jlong jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  int arg2 ;
  Op result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (int)jarg2; 
  result = Op___rsub__(arg1,arg2);
  *(Op **)&jresult = new Op((const Op &)result); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1_1_1str_1_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jstring jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  char *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  result = (char *)Op___str__(arg1);
  if (result) jresult = jenv->NewStringUTF((const char *)result);
  return jresult;
}


SWIGEXPORT jint JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1_1_1getitem_1_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  jint jresult = 0 ;
  Op *arg1 = (Op *) 0 ;
  unsigned int arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  result = (int)Op___getitem__(arg1,arg2);
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_Op_1_1_1setitem_1_1(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jint jarg3) {
  Op *arg1 = (Op *) 0 ;
  unsigned int arg2 ;
  int arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(Op **)&jarg1; 
  arg2 = (unsigned int)jarg2; 
  arg3 = (int)jarg3; 
  Op___setitem__(arg1,arg2,arg3);
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_EqualEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)operator ==((Op const &)*arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_NotEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)operator !=((Op const &)*arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_LessThan(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)operator <((Op const &)*arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_LessThanEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)operator <=((Op const &)*arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_GreaterThan(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)operator >((Op const &)*arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jboolean JNICALL Java_operator_1overload_operator_1overloadJNI_GreaterThanEqual(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2, jobject jarg2_) {
  jboolean jresult = 0 ;
  Op *arg1 = 0 ;
  Op *arg2 = 0 ;
  bool result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg2_;
  arg1 = *(Op **)&jarg1;
  if (!arg1) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  arg2 = *(Op **)&jarg2;
  if (!arg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "Op const & reference is null");
    return 0;
  } 
  result = (bool)operator >=((Op const &)*arg1,(Op const &)*arg2);
  jresult = (jboolean)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_new_1OpDerived_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jint jarg1) {
  jlong jresult = 0 ;
  int arg1 ;
  OpDerived *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = (int)jarg1; 
  result = (OpDerived *)new OpDerived(arg1);
  *(OpDerived **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_new_1OpDerived_1_1SWIG_11(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  OpDerived *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  result = (OpDerived *)new OpDerived();
  *(OpDerived **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_operator_1overload_operator_1overloadJNI_OpDerived_1IntCast(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  OpDerived *arg1 = (OpDerived *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(OpDerived **)&jarg1; 
  result = (int)(arg1)->operator int();
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_operator_1overload_operator_1overloadJNI_delete_1OpDerived(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  OpDerived *arg1 = (OpDerived *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(OpDerived **)&jarg1; 
  delete arg1;
}


SWIGEXPORT jlong JNICALL Java_operator_1overload_operator_1overloadJNI_OpDerived_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(Op **)&baseptr = *(OpDerived **)&jarg1;
    return baseptr;
}

#ifdef __cplusplus
}
#endif

