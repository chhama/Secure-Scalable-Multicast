# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package template_partial_specialization_typedef;
use base qw(Exporter);
use base qw(DynaLoader);
package template_partial_specialization_typedefc;
bootstrap template_partial_specialization_typedef;
package template_partial_specialization_typedef;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package template_partial_specialization_typedef;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package template_partial_specialization_typedef;


############# Class : template_partial_specialization_typedef::A ##############

package template_partial_specialization_typedef::A;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*a = *template_partial_specialization_typedefc::A_a;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_A(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_A($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::B ##############

package template_partial_specialization_typedef::B;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::B_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_B(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_B($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::C ##############

package template_partial_specialization_typedef::C;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*c = *template_partial_specialization_typedefc::C_c;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_C(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_C($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::D ##############

package template_partial_specialization_typedef::D;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*d = *template_partial_specialization_typedefc::D_d;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_D(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_D($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::E ##############

package template_partial_specialization_typedef::E;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*e = *template_partial_specialization_typedefc::E_e;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_E(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_E($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::F ##############

package template_partial_specialization_typedef::F;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*f = *template_partial_specialization_typedefc::F_f;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_F(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_F($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::G ##############

package template_partial_specialization_typedef::G;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*g = *template_partial_specialization_typedefc::G_g;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_G(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_G($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::H ##############

package template_partial_specialization_typedef::H;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*h = *template_partial_specialization_typedefc::H_h;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_H(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_H($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::I ##############

package template_partial_specialization_typedef::I;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*i = *template_partial_specialization_typedefc::I_i;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_I(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_I($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::J ##############

package template_partial_specialization_typedef::J;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*j = *template_partial_specialization_typedefc::J_j;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_J(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_J($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::K ##############

package template_partial_specialization_typedef::K;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*k = *template_partial_specialization_typedefc::K_k;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_K(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_K($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::L ##############

package template_partial_specialization_typedef::L;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*l = *template_partial_specialization_typedefc::L_l;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_L(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_L($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::BB ##############

package template_partial_specialization_typedef::BB;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::BB_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_BB(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_BB($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::BBB ##############

package template_partial_specialization_typedef::BBB;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::BBB_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_BBB(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_BBB($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::BBBB ##############

package template_partial_specialization_typedef::BBBB;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::BBBB_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_BBBB(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_BBBB($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::BBBBB ##############

package template_partial_specialization_typedef::BBBBB;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::BBBBB_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_BBBBB(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_BBBBB($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::B1 ##############

package template_partial_specialization_typedef::B1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::B1_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_B1(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_B1($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::B2 ##############

package template_partial_specialization_typedef::B2;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::B2_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_B2(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_B2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::B3 ##############

package template_partial_specialization_typedef::B3;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::B3_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_B3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_B3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::B4 ##############

package template_partial_specialization_typedef::B4;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::B4_b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_B4(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_B4($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::Concrete ##############

package template_partial_specialization_typedef::Concrete;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_Concrete(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_Concrete($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::A_ ##############

package template_partial_specialization_typedef::A_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*a = *template_partial_specialization_typedefc::A__a;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_A_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_A_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::B_ ##############

package template_partial_specialization_typedef::B_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::B__b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_B_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_B_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::C_ ##############

package template_partial_specialization_typedef::C_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*c = *template_partial_specialization_typedefc::C__c;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_C_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_C_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::D_ ##############

package template_partial_specialization_typedef::D_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*d = *template_partial_specialization_typedefc::D__d;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_D_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_D_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::E_ ##############

package template_partial_specialization_typedef::E_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*e = *template_partial_specialization_typedefc::E__e;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_E_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_E_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::F_ ##############

package template_partial_specialization_typedef::F_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*f = *template_partial_specialization_typedefc::F__f;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_F_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_F_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::G_ ##############

package template_partial_specialization_typedef::G_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*g = *template_partial_specialization_typedefc::G__g;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_G_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_G_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::C1_ ##############

package template_partial_specialization_typedef::C1_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*c = *template_partial_specialization_typedefc::C1__c;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_C1_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_C1_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::C2_ ##############

package template_partial_specialization_typedef::C2_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*c = *template_partial_specialization_typedefc::C2__c;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_C2_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_C2_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::C3_ ##############

package template_partial_specialization_typedef::C3_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*c = *template_partial_specialization_typedefc::C3__c;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_C3_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_C3_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::C4_ ##############

package template_partial_specialization_typedef::C4_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*c = *template_partial_specialization_typedefc::C4__c;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_C4_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_C4_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::B1_ ##############

package template_partial_specialization_typedef::B1_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*b = *template_partial_specialization_typedefc::B1__b;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_B1_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_B1_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::E1_ ##############

package template_partial_specialization_typedef::E1_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*e = *template_partial_specialization_typedefc::E1__e;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_E1_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_E1_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : template_partial_specialization_typedef::E2_ ##############

package template_partial_specialization_typedef::E2_;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( template_partial_specialization_typedef );
%OWNER = ();
%ITERATORS = ();
*e = *template_partial_specialization_typedefc::E2__e;
sub new {
    my $pkg = shift;
    my $self = template_partial_specialization_typedefc::new_E2_(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        template_partial_specialization_typedefc::delete_E2_($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package template_partial_specialization_typedef;

1;
