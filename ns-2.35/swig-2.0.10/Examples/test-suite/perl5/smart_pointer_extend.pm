# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package smart_pointer_extend;
use base qw(Exporter);
use base qw(DynaLoader);
package smart_pointer_extendc;
bootstrap smart_pointer_extend;
package smart_pointer_extend;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package smart_pointer_extend;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package smart_pointer_extend;

*get_hello = *smart_pointer_extendc::get_hello;

############# Class : smart_pointer_extend::CBase ##############

package smart_pointer_extend::CBase;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
*hello = *smart_pointer_extendc::CBase_hello;
*swig_x_get = *smart_pointer_extendc::CBase_x_get;
*swig_x_set = *smart_pointer_extendc::CBase_x_set;
*z = *smart_pointer_extendc::CBase_z;
*z = *smart_pointer_extendc::CBase_z;
*foo = *smart_pointer_extendc::CBase_foo;
*bar = *smart_pointer_extendc::CBase_bar;
*boo = *smart_pointer_extendc::CBase_boo;
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_CBase(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_CBase($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::CDerived ##############

package smart_pointer_extend::CDerived;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend::CBase smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
*foo = *smart_pointer_extendc::CDerived_foo;
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_CDerived(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_CDerived($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::CPtr ##############

package smart_pointer_extend::CPtr;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *smart_pointer_extendc::CPtr___deref__;
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_CPtr(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_CPtr($self);
        delete $OWNER{$self};
    }
}

*foo = *smart_pointer_extendc::CPtr_foo;
*hello = *smart_pointer_extendc::CPtr_hello;
*swig_x_get = *smart_pointer_extendc::CPtr_x_get;
*swig_x_set = *smart_pointer_extendc::CPtr_x_set;
*swig_z_get = *smart_pointer_extendc::CPtr_z_get;
*swig_z_set = *smart_pointer_extendc::CPtr_z_set;
*bar = *smart_pointer_extendc::CPtr_bar;
*boo = *smart_pointer_extendc::CPtr_boo;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::CPtrConst ##############

package smart_pointer_extend::CPtrConst;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *smart_pointer_extendc::CPtrConst___deref__;
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_CPtrConst(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_CPtrConst($self);
        delete $OWNER{$self};
    }
}

*swig_x_get = *smart_pointer_extendc::CPtrConst_x_get;
*swig_x_set = *smart_pointer_extendc::CPtrConst_x_set;
*swig_z_get = *smart_pointer_extendc::CPtrConst_z_get;
*swig_z_set = *smart_pointer_extendc::CPtrConst_z_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::Foo ##############

package smart_pointer_extend::Foo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
*extension = *smart_pointer_extendc::Foo_extension;
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_Foo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_Foo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::Bar ##############

package smart_pointer_extend::Bar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_Bar(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *smart_pointer_extendc::Bar___deref__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_Bar($self);
        delete $OWNER{$self};
    }
}

*extension = *smart_pointer_extendc::Bar_extension;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::CFoo ##############

package smart_pointer_extend::CFoo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
*StatFun = *smart_pointer_extendc::CFoo_StatFun;
*HoHoHo = *smart_pointer_extendc::CFoo_HoHoHo;
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_CFoo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_CFoo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::CPtrFoo ##############

package smart_pointer_extend::CPtrFoo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
*__deref__ = *smart_pointer_extendc::CPtrFoo___deref__;
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_CPtrFoo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_CPtrFoo($self);
        delete $OWNER{$self};
    }
}

*StatFun = *smart_pointer_extendc::CPtrFoo_StatFun;
*HoHoHo = *smart_pointer_extendc::CPtrFoo_HoHoHo;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::DPtrFoo ##############

package smart_pointer_extend::DPtrFoo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_DPtrFoo(@_);
    bless $self, $pkg if defined($self);
}

*__deref__ = *smart_pointer_extendc::DPtrFoo___deref__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_DPtrFoo($self);
        delete $OWNER{$self};
    }
}

*F = *smart_pointer_extendc::DPtrFoo_F;
*SExt = *smart_pointer_extendc::DPtrFoo_SExt;
*Ext = *smart_pointer_extendc::DPtrFoo_Ext;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : smart_pointer_extend::DFoo ##############

package smart_pointer_extend::DFoo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( smart_pointer_extend );
%OWNER = ();
%ITERATORS = ();
*F = *smart_pointer_extendc::DFoo_F;
*SExt = *smart_pointer_extendc::DFoo_SExt;
*Ext = *smart_pointer_extendc::DFoo_Ext;
sub new {
    my $pkg = shift;
    my $self = smart_pointer_extendc::new_DFoo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        smart_pointer_extendc::delete_DFoo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package smart_pointer_extend;

1;
