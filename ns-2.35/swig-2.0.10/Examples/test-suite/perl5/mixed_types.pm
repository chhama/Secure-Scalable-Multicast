# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package mixed_types;
use base qw(Exporter);
use base qw(DynaLoader);
package mixed_typesc;
bootstrap mixed_types;
package mixed_types;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package mixed_types;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package mixed_types;

*ref_pointer = *mixed_typesc::ref_pointer;
*ref_pointer_1 = *mixed_typesc::ref_pointer_1;
*pointer_1 = *mixed_typesc::pointer_1;
*ref_const = *mixed_typesc::ref_const;
*sint = *mixed_typesc::sint;
*ref_int = *mixed_typesc::ref_int;
*senum = *mixed_typesc::senum;
*ref_enum = *mixed_typesc::ref_enum;
*rptr_const = *mixed_typesc::rptr_const;
*rptr_const2 = *mixed_typesc::rptr_const2;
*rptr_void = *mixed_typesc::rptr_void;
*cref_a = *mixed_typesc::cref_a;
*ref_a = *mixed_typesc::ref_a;
*test_a = *mixed_typesc::test_a;
*test_b = *mixed_typesc::test_b;
*test_c = *mixed_typesc::test_c;
*test_d = *mixed_typesc::test_d;
*test_e = *mixed_typesc::test_e;
*test_f = *mixed_typesc::test_f;
*test_g = *mixed_typesc::test_g;
*fn_taking_arrays = *mixed_typesc::fn_taking_arrays;
*get_2d_array = *mixed_typesc::get_2d_array;

############# Class : mixed_types::A ##############

package mixed_types::A;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( mixed_types );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mixed_typesc::new_A(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mixed_typesc::delete_A($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : mixed_types::Foo ##############

package mixed_types::Foo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( mixed_types );
%OWNER = ();
%ITERATORS = ();
*foo = *mixed_typesc::Foo_foo;
*foon = *mixed_typesc::Foo_foon;
sub new {
    my $pkg = shift;
    my $self = mixed_typesc::new_Foo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mixed_typesc::delete_Foo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : mixed_types::SimpleStruct ##############

package mixed_types::SimpleStruct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( mixed_types );
%OWNER = ();
%ITERATORS = ();
*swig_double_field_get = *mixed_typesc::SimpleStruct_double_field_get;
*swig_double_field_set = *mixed_typesc::SimpleStruct_double_field_set;
sub new {
    my $pkg = shift;
    my $self = mixed_typesc::new_SimpleStruct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mixed_typesc::delete_SimpleStruct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package mixed_types;

*hi = *mixed_typesc::hi;
*hello = *mixed_typesc::hello;
*ARRAY_LEN_X = *mixed_typesc::ARRAY_LEN_X;
*ARRAY_LEN_Y = *mixed_typesc::ARRAY_LEN_Y;
*One = *mixed_typesc::One;
*Two = *mixed_typesc::Two;
*Three = *mixed_typesc::Three;
*Four = *mixed_typesc::Four;
*Five = *mixed_typesc::Five;
*array_c = *mixed_typesc::array_c;
*array_sc = *mixed_typesc::array_sc;
*array_uc = *mixed_typesc::array_uc;
*array_s = *mixed_typesc::array_s;
*array_us = *mixed_typesc::array_us;
*array_i = *mixed_typesc::array_i;
*array_ui = *mixed_typesc::array_ui;
*array_l = *mixed_typesc::array_l;
*array_ul = *mixed_typesc::array_ul;
*array_ll = *mixed_typesc::array_ll;
*array_f = *mixed_typesc::array_f;
*array_d = *mixed_typesc::array_d;
*array_struct = *mixed_typesc::array_struct;
*array_structpointers = *mixed_typesc::array_structpointers;
*array_ipointers = *mixed_typesc::array_ipointers;
*array_enum = *mixed_typesc::array_enum;
*array_enumpointers = *mixed_typesc::array_enumpointers;
*array_const_i = *mixed_typesc::array_const_i;
1;
