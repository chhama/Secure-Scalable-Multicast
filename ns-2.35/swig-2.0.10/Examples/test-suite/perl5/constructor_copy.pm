# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package constructor_copy;
use base qw(Exporter);
use base qw(DynaLoader);
package constructor_copyc;
bootstrap constructor_copy;
package constructor_copy;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package constructor_copy;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package constructor_copy;


############# Class : constructor_copy::Foo1 ##############

package constructor_copy::Foo1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *constructor_copyc::Foo1_x_get;
*swig_x_set = *constructor_copyc::Foo1_x_set;
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo1(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo1($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Foo2 ##############

package constructor_copy::Foo2;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo2(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Foo3 ##############

package constructor_copy::Foo3;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Foo4 ##############

package constructor_copy::Foo4;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo4(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo4($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Foo4a ##############

package constructor_copy::Foo4a;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo4a(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo4a($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Foo5 ##############

package constructor_copy::Foo5;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy::Foo4 constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo5(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo5($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Foo6 ##############

package constructor_copy::Foo6;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy::Foo4 constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo6(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo6($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Foo7 ##############

package constructor_copy::Foo7;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy::Foo5 constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo7(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo7($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Foo8 ##############

package constructor_copy::Foo8;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Foo8(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Foo8($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Bari ##############

package constructor_copy::Bari;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *constructor_copyc::Bari_x_get;
*swig_x_set = *constructor_copyc::Bari_x_set;
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Bari(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Bari($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Bard ##############

package constructor_copy::Bard;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *constructor_copyc::Bard_x_get;
*swig_x_set = *constructor_copyc::Bard_x_set;
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Bard(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Bard($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Flow ##############

package constructor_copy::Flow;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Flow(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Flow($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::FlowFlow ##############

package constructor_copy::FlowFlow;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_FlowFlow(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_FlowFlow($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::VectFlow ##############

package constructor_copy::VectFlow;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_VectFlow(@_);
    bless $self, $pkg if defined($self);
}

*size = *constructor_copyc::VectFlow_size;
*empty = *constructor_copyc::VectFlow_empty;
*clear = *constructor_copyc::VectFlow_clear;
*push = *constructor_copyc::VectFlow_push;
*pop = *constructor_copyc::VectFlow_pop;
*get = *constructor_copyc::VectFlow_get;
*set = *constructor_copyc::VectFlow_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_VectFlow($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::ABC_Libor_ModelUtils ##############

package constructor_copy::ABC_Libor_ModelUtils;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_ABC_Libor_ModelUtils(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_ABC_Libor_ModelUtils($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::ModelUtils_i ##############

package constructor_copy::ModelUtils_i;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_ModelUtils_i(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_ModelUtils_i($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Space1Space2_TotalReturnSwap ##############

package constructor_copy::Space1Space2_TotalReturnSwap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Space1Space2_TotalReturnSwap(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Space1Space2_TotalReturnSwap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constructor_copy::Total_i ##############

package constructor_copy::Total_i;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constructor_copy );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constructor_copyc::new_Total_i(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constructor_copyc::delete_Total_i($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package constructor_copy;

1;
