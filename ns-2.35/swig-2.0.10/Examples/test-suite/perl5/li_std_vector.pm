# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package li_std_vector;
use base qw(Exporter);
use base qw(DynaLoader);
package li_std_vectorc;
bootstrap li_std_vector;
package li_std_vector;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package li_std_vector;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package li_std_vector;

*typedef_test = *li_std_vectorc::typedef_test;
*average = *li_std_vectorc::average;
*half = *li_std_vectorc::half;
*halve_in_place = *li_std_vectorc::halve_in_place;
*vecreal = *li_std_vectorc::vecreal;
*vecintptr = *li_std_vectorc::vecintptr;
*vecintconstptr = *li_std_vectorc::vecintconstptr;
*vecstruct = *li_std_vectorc::vecstruct;
*vecstructptr = *li_std_vectorc::vecstructptr;
*vecstructconstptr = *li_std_vectorc::vecstructconstptr;

############# Class : li_std_vector::IntVector ##############

package li_std_vector::IntVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_IntVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::IntVector_size;
*empty = *li_std_vectorc::IntVector_empty;
*clear = *li_std_vectorc::IntVector_clear;
*push = *li_std_vectorc::IntVector_push;
*pop = *li_std_vectorc::IntVector_pop;
*get = *li_std_vectorc::IntVector_get;
*set = *li_std_vectorc::IntVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_IntVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::BoolVector ##############

package li_std_vector::BoolVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_BoolVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::BoolVector_size;
*empty = *li_std_vectorc::BoolVector_empty;
*clear = *li_std_vectorc::BoolVector_clear;
*push = *li_std_vectorc::BoolVector_push;
*pop = *li_std_vectorc::BoolVector_pop;
*get = *li_std_vectorc::BoolVector_get;
*set = *li_std_vectorc::BoolVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_BoolVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::CharVector ##############

package li_std_vector::CharVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_CharVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::CharVector_size;
*empty = *li_std_vectorc::CharVector_empty;
*clear = *li_std_vectorc::CharVector_clear;
*push = *li_std_vectorc::CharVector_push;
*pop = *li_std_vectorc::CharVector_pop;
*get = *li_std_vectorc::CharVector_get;
*set = *li_std_vectorc::CharVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_CharVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::ShortVector ##############

package li_std_vector::ShortVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_ShortVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::ShortVector_size;
*empty = *li_std_vectorc::ShortVector_empty;
*clear = *li_std_vectorc::ShortVector_clear;
*push = *li_std_vectorc::ShortVector_push;
*pop = *li_std_vectorc::ShortVector_pop;
*get = *li_std_vectorc::ShortVector_get;
*set = *li_std_vectorc::ShortVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_ShortVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::LongVector ##############

package li_std_vector::LongVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_LongVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::LongVector_size;
*empty = *li_std_vectorc::LongVector_empty;
*clear = *li_std_vectorc::LongVector_clear;
*push = *li_std_vectorc::LongVector_push;
*pop = *li_std_vectorc::LongVector_pop;
*get = *li_std_vectorc::LongVector_get;
*set = *li_std_vectorc::LongVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_LongVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::UCharVector ##############

package li_std_vector::UCharVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_UCharVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::UCharVector_size;
*empty = *li_std_vectorc::UCharVector_empty;
*clear = *li_std_vectorc::UCharVector_clear;
*push = *li_std_vectorc::UCharVector_push;
*pop = *li_std_vectorc::UCharVector_pop;
*get = *li_std_vectorc::UCharVector_get;
*set = *li_std_vectorc::UCharVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_UCharVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::UIntVector ##############

package li_std_vector::UIntVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_UIntVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::UIntVector_size;
*empty = *li_std_vectorc::UIntVector_empty;
*clear = *li_std_vectorc::UIntVector_clear;
*push = *li_std_vectorc::UIntVector_push;
*pop = *li_std_vectorc::UIntVector_pop;
*get = *li_std_vectorc::UIntVector_get;
*set = *li_std_vectorc::UIntVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_UIntVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::UShortVector ##############

package li_std_vector::UShortVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_UShortVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::UShortVector_size;
*empty = *li_std_vectorc::UShortVector_empty;
*clear = *li_std_vectorc::UShortVector_clear;
*push = *li_std_vectorc::UShortVector_push;
*pop = *li_std_vectorc::UShortVector_pop;
*get = *li_std_vectorc::UShortVector_get;
*set = *li_std_vectorc::UShortVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_UShortVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::ULongVector ##############

package li_std_vector::ULongVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_ULongVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::ULongVector_size;
*empty = *li_std_vectorc::ULongVector_empty;
*clear = *li_std_vectorc::ULongVector_clear;
*push = *li_std_vectorc::ULongVector_push;
*pop = *li_std_vectorc::ULongVector_pop;
*get = *li_std_vectorc::ULongVector_get;
*set = *li_std_vectorc::ULongVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_ULongVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::DoubleVector ##############

package li_std_vector::DoubleVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_DoubleVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::DoubleVector_size;
*empty = *li_std_vectorc::DoubleVector_empty;
*clear = *li_std_vectorc::DoubleVector_clear;
*push = *li_std_vectorc::DoubleVector_push;
*pop = *li_std_vectorc::DoubleVector_pop;
*get = *li_std_vectorc::DoubleVector_get;
*set = *li_std_vectorc::DoubleVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_DoubleVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::StringVector ##############

package li_std_vector::StringVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_StringVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::StringVector_size;
*empty = *li_std_vectorc::StringVector_empty;
*clear = *li_std_vectorc::StringVector_clear;
*push = *li_std_vectorc::StringVector_push;
*pop = *li_std_vectorc::StringVector_pop;
*get = *li_std_vectorc::StringVector_get;
*set = *li_std_vectorc::StringVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_StringVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::RealVector ##############

package li_std_vector::RealVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_RealVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::RealVector_size;
*empty = *li_std_vectorc::RealVector_empty;
*clear = *li_std_vectorc::RealVector_clear;
*push = *li_std_vectorc::RealVector_push;
*pop = *li_std_vectorc::RealVector_pop;
*get = *li_std_vectorc::RealVector_get;
*set = *li_std_vectorc::RealVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_RealVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::Struct ##############

package li_std_vector::Struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
*swig_num_get = *li_std_vectorc::Struct_num_get;
*swig_num_set = *li_std_vectorc::Struct_num_set;
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_Struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_Struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::Structure ##############

package li_std_vector::Structure;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
*swig_num_get = *li_std_vectorc::Structure_num_get;
*swig_num_set = *li_std_vectorc::Structure_num_set;
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_Structure(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_Structure($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::IntPtrVector ##############

package li_std_vector::IntPtrVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_IntPtrVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::IntPtrVector_size;
*empty = *li_std_vectorc::IntPtrVector_empty;
*clear = *li_std_vectorc::IntPtrVector_clear;
*push = *li_std_vectorc::IntPtrVector_push;
*pop = *li_std_vectorc::IntPtrVector_pop;
*get = *li_std_vectorc::IntPtrVector_get;
*set = *li_std_vectorc::IntPtrVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_IntPtrVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::IntConstPtrVector ##############

package li_std_vector::IntConstPtrVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_IntConstPtrVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::IntConstPtrVector_size;
*empty = *li_std_vectorc::IntConstPtrVector_empty;
*clear = *li_std_vectorc::IntConstPtrVector_clear;
*push = *li_std_vectorc::IntConstPtrVector_push;
*pop = *li_std_vectorc::IntConstPtrVector_pop;
*get = *li_std_vectorc::IntConstPtrVector_get;
*set = *li_std_vectorc::IntConstPtrVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_IntConstPtrVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::StructVector ##############

package li_std_vector::StructVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_StructVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::StructVector_size;
*empty = *li_std_vectorc::StructVector_empty;
*clear = *li_std_vectorc::StructVector_clear;
*push = *li_std_vectorc::StructVector_push;
*pop = *li_std_vectorc::StructVector_pop;
*get = *li_std_vectorc::StructVector_get;
*set = *li_std_vectorc::StructVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_StructVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::StructPtrVector ##############

package li_std_vector::StructPtrVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_StructPtrVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::StructPtrVector_size;
*empty = *li_std_vectorc::StructPtrVector_empty;
*clear = *li_std_vectorc::StructPtrVector_clear;
*push = *li_std_vectorc::StructPtrVector_push;
*pop = *li_std_vectorc::StructPtrVector_pop;
*get = *li_std_vectorc::StructPtrVector_get;
*set = *li_std_vectorc::StructPtrVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_StructPtrVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::StructConstPtrVector ##############

package li_std_vector::StructConstPtrVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_StructConstPtrVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::StructConstPtrVector_size;
*empty = *li_std_vectorc::StructConstPtrVector_empty;
*clear = *li_std_vectorc::StructConstPtrVector_clear;
*push = *li_std_vectorc::StructConstPtrVector_push;
*pop = *li_std_vectorc::StructConstPtrVector_pop;
*get = *li_std_vectorc::StructConstPtrVector_get;
*set = *li_std_vectorc::StructConstPtrVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_StructConstPtrVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::MyClass ##############

package li_std_vector::MyClass;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_MyClass(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_MyClass($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::MyClassPtrVector ##############

package li_std_vector::MyClassPtrVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_MyClassPtrVector(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_vectorc::MyClassPtrVector_size;
*empty = *li_std_vectorc::MyClassPtrVector_empty;
*clear = *li_std_vectorc::MyClassPtrVector_clear;
*push = *li_std_vectorc::MyClassPtrVector_push;
*pop = *li_std_vectorc::MyClassPtrVector_pop;
*get = *li_std_vectorc::MyClassPtrVector_get;
*set = *li_std_vectorc::MyClassPtrVector_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_MyClassPtrVector($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_vector::RetsMetadata ##############

package li_std_vector::RetsMetadata;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_vector );
%OWNER = ();
%ITERATORS = ();
*GetAllResources = *li_std_vectorc::RetsMetadata_GetAllResources;
sub new {
    my $pkg = shift;
    my $self = li_std_vectorc::new_RetsMetadata(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_vectorc::delete_RetsMetadata($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package li_std_vector;

1;
