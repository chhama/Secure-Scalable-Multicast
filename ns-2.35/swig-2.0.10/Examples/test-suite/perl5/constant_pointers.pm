# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package constant_pointers;
use base qw(Exporter);
use base qw(DynaLoader);
package constant_pointersc;
bootstrap constant_pointers;
package constant_pointers;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package constant_pointers;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package constant_pointers;

*foofunction = *constant_pointersc::foofunction;
*globalRet1 = *constant_pointersc::globalRet1;
*globalRet2 = *constant_pointersc::globalRet2;
*opaque = *constant_pointersc::opaque;
*bar = *constant_pointersc::bar;
*cbar = *constant_pointersc::cbar;

############# Class : constant_pointers::ParametersTest ##############

package constant_pointers::ParametersTest;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constant_pointers );
%OWNER = ();
%ITERATORS = ();
*param1 = *constant_pointersc::ParametersTest_param1;
*param2 = *constant_pointersc::ParametersTest_param2;
*param3 = *constant_pointersc::ParametersTest_param3;
*param4 = *constant_pointersc::ParametersTest_param4;
*param5 = *constant_pointersc::ParametersTest_param5;
*param6 = *constant_pointersc::ParametersTest_param6;
*param7 = *constant_pointersc::ParametersTest_param7;
*param8 = *constant_pointersc::ParametersTest_param8;
*param9 = *constant_pointersc::ParametersTest_param9;
*param10 = *constant_pointersc::ParametersTest_param10;
*param11 = *constant_pointersc::ParametersTest_param11;
*param_array1 = *constant_pointersc::ParametersTest_param_array1;
*param_array2 = *constant_pointersc::ParametersTest_param_array2;
*param_array3 = *constant_pointersc::ParametersTest_param_array3;
*param_array4 = *constant_pointersc::ParametersTest_param_array4;
*param_array5 = *constant_pointersc::ParametersTest_param_array5;
*param_array6 = *constant_pointersc::ParametersTest_param_array6;
sub new {
    my $pkg = shift;
    my $self = constant_pointersc::new_ParametersTest(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constant_pointersc::delete_ParametersTest($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constant_pointers::MemberVariablesTest ##############

package constant_pointers::MemberVariablesTest;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constant_pointers );
%OWNER = ();
%ITERATORS = ();
*swig_member1_get = *constant_pointersc::MemberVariablesTest_member1_get;
*swig_member1_set = *constant_pointersc::MemberVariablesTest_member1_set;
*swig_member2_get = *constant_pointersc::MemberVariablesTest_member2_get;
*swig_member2_set = *constant_pointersc::MemberVariablesTest_member2_set;
*swig_member3_get = *constant_pointersc::MemberVariablesTest_member3_get;
*swig_member3_set = *constant_pointersc::MemberVariablesTest_member3_set;
*swig_member4_get = *constant_pointersc::MemberVariablesTest_member4_get;
*swig_member4_set = *constant_pointersc::MemberVariablesTest_member4_set;
*swig_array_member1_get = *constant_pointersc::MemberVariablesTest_array_member1_get;
*swig_array_member1_set = *constant_pointersc::MemberVariablesTest_array_member1_set;
*swig_array_member2_get = *constant_pointersc::MemberVariablesTest_array_member2_get;
*swig_array_member2_set = *constant_pointersc::MemberVariablesTest_array_member2_set;
sub new {
    my $pkg = shift;
    my $self = constant_pointersc::new_MemberVariablesTest(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constant_pointersc::delete_MemberVariablesTest($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constant_pointers::ReturnValuesTest ##############

package constant_pointers::ReturnValuesTest;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constant_pointers );
%OWNER = ();
%ITERATORS = ();
*swig_td1_get = *constant_pointersc::ReturnValuesTest_td1_get;
*swig_td1_set = *constant_pointersc::ReturnValuesTest_td1_set;
*swig_td2_get = *constant_pointersc::ReturnValuesTest_td2_get;
*swig_td2_set = *constant_pointersc::ReturnValuesTest_td2_set;
*swig_int1_get = *constant_pointersc::ReturnValuesTest_int1_get;
*swig_int1_set = *constant_pointersc::ReturnValuesTest_int1_set;
*swig_int2_get = *constant_pointersc::ReturnValuesTest_int2_get;
*swig_int2_set = *constant_pointersc::ReturnValuesTest_int2_set;
*swig_int3_get = *constant_pointersc::ReturnValuesTest_int3_get;
*swig_int3_set = *constant_pointersc::ReturnValuesTest_int3_set;
*swig_int4_get = *constant_pointersc::ReturnValuesTest_int4_get;
*swig_int4_set = *constant_pointersc::ReturnValuesTest_int4_set;
*swig_array1_get = *constant_pointersc::ReturnValuesTest_array1_get;
*swig_array1_set = *constant_pointersc::ReturnValuesTest_array1_set;
*ret1 = *constant_pointersc::ReturnValuesTest_ret1;
*ret2 = *constant_pointersc::ReturnValuesTest_ret2;
*ret3 = *constant_pointersc::ReturnValuesTest_ret3;
*ret4 = *constant_pointersc::ReturnValuesTest_ret4;
*ret5 = *constant_pointersc::ReturnValuesTest_ret5;
*ret6 = *constant_pointersc::ReturnValuesTest_ret6;
*ret7 = *constant_pointersc::ReturnValuesTest_ret7;
*ret8 = *constant_pointersc::ReturnValuesTest_ret8;
*ret9 = *constant_pointersc::ReturnValuesTest_ret9;
sub new {
    my $pkg = shift;
    my $self = constant_pointersc::new_ReturnValuesTest(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constant_pointersc::delete_ReturnValuesTest($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constant_pointers::B ##############

package constant_pointers::B;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constant_pointers );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = constant_pointersc::new_B(@_);
    bless $self, $pkg if defined($self);
}

*swig_ca_get = *constant_pointersc::B_ca_get;
*swig_ca_set = *constant_pointersc::B_ca_set;
*swig_a_get = *constant_pointersc::B_a_get;
*swig_a_set = *constant_pointersc::B_a_set;
*swig_ap_get = *constant_pointersc::B_ap_get;
*swig_ap_set = *constant_pointersc::B_ap_set;
*swig_cap_get = *constant_pointersc::B_cap_get;
*swig_cap_set = *constant_pointersc::B_cap_set;
*swig_acptr_get = *constant_pointersc::B_acptr_get;
*swig_acptr_set = *constant_pointersc::B_acptr_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constant_pointersc::delete_B($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : constant_pointers::Foo ##############

package constant_pointers::Foo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( constant_pointers );
%OWNER = ();
%ITERATORS = ();
*swig_icap_get = *constant_pointersc::Foo_icap_get;
*swig_icap_set = *constant_pointersc::Foo_icap_set;
sub new {
    my $pkg = shift;
    my $self = constant_pointersc::new_Foo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        constant_pointersc::delete_Foo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package constant_pointers;

*GlobalInt = *constant_pointersc::GlobalInt;
*ConstInt = *constant_pointersc::ConstInt;
*GlobalIntPtr = *constant_pointersc::GlobalIntPtr;
*GlobalConstIntPtr = *constant_pointersc::GlobalConstIntPtr;
*ARRAY_SIZE = *constant_pointersc::ARRAY_SIZE;
*int1 = *constant_pointersc::int1;
*int2 = *constant_pointersc::int2;
*int3 = *constant_pointersc::int3;
*int4 = *constant_pointersc::int4;
*global_const_int_ptr_array = *constant_pointersc::global_const_int_ptr_array;
*array_member4 = *constant_pointersc::array_member4;
*wxEVENT_COMMAND_BUTTON_CLICKEDr = *constant_pointersc::wxEVENT_COMMAND_BUTTON_CLICKEDr;
*wxEVENT_COMMAND_BUTTON_CLICKEDp = *constant_pointersc::wxEVENT_COMMAND_BUTTON_CLICKEDp;
*languages1 = *constant_pointersc::languages1;
*languages2 = *constant_pointersc::languages2;
*icap = *constant_pointersc::icap;

my %__cap_hash;
tie %__cap_hash,"constant_pointers::Foo", $constant_pointersc::cap;
$cap= \%__cap_hash;
bless $cap, constant_pointers::Foo;
1;
