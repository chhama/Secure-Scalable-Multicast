# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package director_primitives;
use base qw(Exporter);
use base qw(DynaLoader);
package director_primitivesc;
bootstrap director_primitives;
package director_primitives;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package director_primitives;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package director_primitives;


############# Class : director_primitives::Base ##############

package director_primitives::Base;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( director_primitives );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = director_primitivesc::new_Base(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        director_primitivesc::delete_Base($self);
        delete $OWNER{$self};
    }
}

*NoParmsMethod = *director_primitivesc::Base_NoParmsMethod;
*BoolMethod = *director_primitivesc::Base_BoolMethod;
*IntMethod = *director_primitivesc::Base_IntMethod;
*UIntMethod = *director_primitivesc::Base_UIntMethod;
*FloatMethod = *director_primitivesc::Base_FloatMethod;
*CharPtrMethod = *director_primitivesc::Base_CharPtrMethod;
*ConstCharPtrMethod = *director_primitivesc::Base_ConstCharPtrMethod;
*EnumMethod = *director_primitivesc::Base_EnumMethod;
*ManyParmsMethod = *director_primitivesc::Base_ManyParmsMethod;
*NotOverriddenMethod = *director_primitivesc::Base_NotOverriddenMethod;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : director_primitives::Derived ##############

package director_primitives::Derived;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( director_primitives::Base director_primitives );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = director_primitivesc::new_Derived(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        director_primitivesc::delete_Derived($self);
        delete $OWNER{$self};
    }
}

*NoParmsMethod = *director_primitivesc::Derived_NoParmsMethod;
*BoolMethod = *director_primitivesc::Derived_BoolMethod;
*IntMethod = *director_primitivesc::Derived_IntMethod;
*UIntMethod = *director_primitivesc::Derived_UIntMethod;
*FloatMethod = *director_primitivesc::Derived_FloatMethod;
*CharPtrMethod = *director_primitivesc::Derived_CharPtrMethod;
*ConstCharPtrMethod = *director_primitivesc::Derived_ConstCharPtrMethod;
*EnumMethod = *director_primitivesc::Derived_EnumMethod;
*ManyParmsMethod = *director_primitivesc::Derived_ManyParmsMethod;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : director_primitives::Caller ##############

package director_primitives::Caller;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( director_primitives );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = director_primitivesc::new_Caller(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        director_primitivesc::delete_Caller($self);
        delete $OWNER{$self};
    }
}

*set = *director_primitivesc::Caller_set;
*reset = *director_primitivesc::Caller_reset;
*NoParmsMethodCall = *director_primitivesc::Caller_NoParmsMethodCall;
*BoolMethodCall = *director_primitivesc::Caller_BoolMethodCall;
*IntMethodCall = *director_primitivesc::Caller_IntMethodCall;
*UIntMethodCall = *director_primitivesc::Caller_UIntMethodCall;
*FloatMethodCall = *director_primitivesc::Caller_FloatMethodCall;
*CharPtrMethodCall = *director_primitivesc::Caller_CharPtrMethodCall;
*ConstCharPtrMethodCall = *director_primitivesc::Caller_ConstCharPtrMethodCall;
*EnumMethodCall = *director_primitivesc::Caller_EnumMethodCall;
*ManyParmsMethodCall = *director_primitivesc::Caller_ManyParmsMethodCall;
*NotOverriddenMethodCall = *director_primitivesc::Caller_NotOverriddenMethodCall;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package director_primitives;

*PrintDebug = *director_primitivesc::PrintDebug;
*HShadowNone = *director_primitivesc::HShadowNone;
*HShadowSoft = *director_primitivesc::HShadowSoft;
*HShadowHard = *director_primitivesc::HShadowHard;
1;
