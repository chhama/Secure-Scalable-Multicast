# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package li_stdint;
use base qw(Exporter);
use base qw(DynaLoader);
package li_stdintc;
bootstrap li_stdint;
package li_stdint;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package li_stdint;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package li_stdint;

*int8_td = *li_stdintc::int8_td;
*int16_td = *li_stdintc::int16_td;
*int32_td = *li_stdintc::int32_td;
*int64_td = *li_stdintc::int64_td;
*uint8_td = *li_stdintc::uint8_td;
*uint16_td = *li_stdintc::uint16_td;
*uint32_td = *li_stdintc::uint32_td;
*uint64_td = *li_stdintc::uint64_td;
*int_fast8_td = *li_stdintc::int_fast8_td;
*int_fast16_td = *li_stdintc::int_fast16_td;
*int_fast32_td = *li_stdintc::int_fast32_td;
*int_fast64_td = *li_stdintc::int_fast64_td;
*uint_fast8_td = *li_stdintc::uint_fast8_td;
*uint_fast16_td = *li_stdintc::uint_fast16_td;
*uint_fast32_td = *li_stdintc::uint_fast32_td;
*uint_fast64_td = *li_stdintc::uint_fast64_td;
*int_least8_td = *li_stdintc::int_least8_td;
*int_least16_td = *li_stdintc::int_least16_td;
*int_least32_td = *li_stdintc::int_least32_td;
*int_least64_td = *li_stdintc::int_least64_td;
*uint_least8_td = *li_stdintc::uint_least8_td;
*uint_least16_td = *li_stdintc::uint_least16_td;
*uint_least32_td = *li_stdintc::uint_least32_td;
*uint_least64_td = *li_stdintc::uint_least64_td;

############# Class : li_stdint::StdInts ##############

package li_stdint::StdInts;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_stdint );
%OWNER = ();
%ITERATORS = ();
*swig_int8_member_get = *li_stdintc::StdInts_int8_member_get;
*swig_int8_member_set = *li_stdintc::StdInts_int8_member_set;
*swig_int16_member_get = *li_stdintc::StdInts_int16_member_get;
*swig_int16_member_set = *li_stdintc::StdInts_int16_member_set;
*swig_int32_member_get = *li_stdintc::StdInts_int32_member_get;
*swig_int32_member_set = *li_stdintc::StdInts_int32_member_set;
*swig_int64_member_get = *li_stdintc::StdInts_int64_member_get;
*swig_int64_member_set = *li_stdintc::StdInts_int64_member_set;
*swig_uint8_member_get = *li_stdintc::StdInts_uint8_member_get;
*swig_uint8_member_set = *li_stdintc::StdInts_uint8_member_set;
*swig_uint16_member_get = *li_stdintc::StdInts_uint16_member_get;
*swig_uint16_member_set = *li_stdintc::StdInts_uint16_member_set;
*swig_uint32_member_get = *li_stdintc::StdInts_uint32_member_get;
*swig_uint32_member_set = *li_stdintc::StdInts_uint32_member_set;
*swig_uint64_member_get = *li_stdintc::StdInts_uint64_member_get;
*swig_uint64_member_set = *li_stdintc::StdInts_uint64_member_set;
sub new {
    my $pkg = shift;
    my $self = li_stdintc::new_StdInts(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_stdintc::delete_StdInts($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_stdint::StdIntFasts ##############

package li_stdint::StdIntFasts;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_stdint );
%OWNER = ();
%ITERATORS = ();
*swig_int_fast8_member_get = *li_stdintc::StdIntFasts_int_fast8_member_get;
*swig_int_fast8_member_set = *li_stdintc::StdIntFasts_int_fast8_member_set;
*swig_int_fast16_member_get = *li_stdintc::StdIntFasts_int_fast16_member_get;
*swig_int_fast16_member_set = *li_stdintc::StdIntFasts_int_fast16_member_set;
*swig_int_fast32_member_get = *li_stdintc::StdIntFasts_int_fast32_member_get;
*swig_int_fast32_member_set = *li_stdintc::StdIntFasts_int_fast32_member_set;
*swig_int_fast64_member_get = *li_stdintc::StdIntFasts_int_fast64_member_get;
*swig_int_fast64_member_set = *li_stdintc::StdIntFasts_int_fast64_member_set;
*swig_uint_fast8_member_get = *li_stdintc::StdIntFasts_uint_fast8_member_get;
*swig_uint_fast8_member_set = *li_stdintc::StdIntFasts_uint_fast8_member_set;
*swig_uint_fast16_member_get = *li_stdintc::StdIntFasts_uint_fast16_member_get;
*swig_uint_fast16_member_set = *li_stdintc::StdIntFasts_uint_fast16_member_set;
*swig_uint_fast32_member_get = *li_stdintc::StdIntFasts_uint_fast32_member_get;
*swig_uint_fast32_member_set = *li_stdintc::StdIntFasts_uint_fast32_member_set;
*swig_uint_fast64_member_get = *li_stdintc::StdIntFasts_uint_fast64_member_get;
*swig_uint_fast64_member_set = *li_stdintc::StdIntFasts_uint_fast64_member_set;
sub new {
    my $pkg = shift;
    my $self = li_stdintc::new_StdIntFasts(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_stdintc::delete_StdIntFasts($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_stdint::StdIntLeasts ##############

package li_stdint::StdIntLeasts;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_stdint );
%OWNER = ();
%ITERATORS = ();
*swig_int_least8_member_get = *li_stdintc::StdIntLeasts_int_least8_member_get;
*swig_int_least8_member_set = *li_stdintc::StdIntLeasts_int_least8_member_set;
*swig_int_least16_member_get = *li_stdintc::StdIntLeasts_int_least16_member_get;
*swig_int_least16_member_set = *li_stdintc::StdIntLeasts_int_least16_member_set;
*swig_int_least32_member_get = *li_stdintc::StdIntLeasts_int_least32_member_get;
*swig_int_least32_member_set = *li_stdintc::StdIntLeasts_int_least32_member_set;
*swig_int_least64_member_get = *li_stdintc::StdIntLeasts_int_least64_member_get;
*swig_int_least64_member_set = *li_stdintc::StdIntLeasts_int_least64_member_set;
*swig_uint_least8_member_get = *li_stdintc::StdIntLeasts_uint_least8_member_get;
*swig_uint_least8_member_set = *li_stdintc::StdIntLeasts_uint_least8_member_set;
*swig_uint_least16_member_get = *li_stdintc::StdIntLeasts_uint_least16_member_get;
*swig_uint_least16_member_set = *li_stdintc::StdIntLeasts_uint_least16_member_set;
*swig_uint_least32_member_get = *li_stdintc::StdIntLeasts_uint_least32_member_get;
*swig_uint_least32_member_set = *li_stdintc::StdIntLeasts_uint_least32_member_set;
*swig_uint_least64_member_get = *li_stdintc::StdIntLeasts_uint_least64_member_get;
*swig_uint_least64_member_set = *li_stdintc::StdIntLeasts_uint_least64_member_set;
sub new {
    my $pkg = shift;
    my $self = li_stdintc::new_StdIntLeasts(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_stdintc::delete_StdIntLeasts($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package li_stdint;

1;
