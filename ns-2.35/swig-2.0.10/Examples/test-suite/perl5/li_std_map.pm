# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package li_std_map;
use base qw(Exporter);
use base qw(DynaLoader);
package li_std_mapc;
bootstrap li_std_map;
package li_std_map;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package li_std_map;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package li_std_map;

*valueAverage = *li_std_mapc::valueAverage;
*stringifyKeys = *li_std_mapc::stringifyKeys;
*p_identa = *li_std_mapc::p_identa;
*m_identa = *li_std_mapc::m_identa;

############# Class : li_std_map::map ##############

package li_std_map::map;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
*swig_val_get = *li_std_mapc::map_val_get;
*swig_val_set = *li_std_mapc::map_val_set;
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_map(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_map($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::IntIntMap ##############

package li_std_map::IntIntMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_IntIntMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::IntIntMap_size;
*empty = *li_std_mapc::IntIntMap_empty;
*clear = *li_std_mapc::IntIntMap_clear;
*get = *li_std_mapc::IntIntMap_get;
*set = *li_std_mapc::IntIntMap_set;
*del = *li_std_mapc::IntIntMap_del;
*has_key = *li_std_mapc::IntIntMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_IntIntMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::StringIntMap ##############

package li_std_map::StringIntMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_StringIntMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::StringIntMap_size;
*empty = *li_std_mapc::StringIntMap_empty;
*clear = *li_std_mapc::StringIntMap_clear;
*get = *li_std_mapc::StringIntMap_get;
*set = *li_std_mapc::StringIntMap_set;
*del = *li_std_mapc::StringIntMap_del;
*has_key = *li_std_mapc::StringIntMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_StringIntMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::Struct ##############

package li_std_map::Struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
*swig_num_get = *li_std_mapc::Struct_num_get;
*swig_num_set = *li_std_mapc::Struct_num_set;
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_Struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_Struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::IntIntPtrMap ##############

package li_std_map::IntIntPtrMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_IntIntPtrMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::IntIntPtrMap_size;
*empty = *li_std_mapc::IntIntPtrMap_empty;
*clear = *li_std_mapc::IntIntPtrMap_clear;
*get = *li_std_mapc::IntIntPtrMap_get;
*set = *li_std_mapc::IntIntPtrMap_set;
*del = *li_std_mapc::IntIntPtrMap_del;
*has_key = *li_std_mapc::IntIntPtrMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_IntIntPtrMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::IntConstIntPtrMap ##############

package li_std_map::IntConstIntPtrMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_IntConstIntPtrMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::IntConstIntPtrMap_size;
*empty = *li_std_mapc::IntConstIntPtrMap_empty;
*clear = *li_std_mapc::IntConstIntPtrMap_clear;
*get = *li_std_mapc::IntConstIntPtrMap_get;
*set = *li_std_mapc::IntConstIntPtrMap_set;
*del = *li_std_mapc::IntConstIntPtrMap_del;
*has_key = *li_std_mapc::IntConstIntPtrMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_IntConstIntPtrMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::IntStructMap ##############

package li_std_map::IntStructMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_IntStructMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::IntStructMap_size;
*empty = *li_std_mapc::IntStructMap_empty;
*clear = *li_std_mapc::IntStructMap_clear;
*get = *li_std_mapc::IntStructMap_get;
*set = *li_std_mapc::IntStructMap_set;
*del = *li_std_mapc::IntStructMap_del;
*has_key = *li_std_mapc::IntStructMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_IntStructMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::IntStructPtrMap ##############

package li_std_map::IntStructPtrMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_IntStructPtrMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::IntStructPtrMap_size;
*empty = *li_std_mapc::IntStructPtrMap_empty;
*clear = *li_std_mapc::IntStructPtrMap_clear;
*get = *li_std_mapc::IntStructPtrMap_get;
*set = *li_std_mapc::IntStructPtrMap_set;
*del = *li_std_mapc::IntStructPtrMap_del;
*has_key = *li_std_mapc::IntStructPtrMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_IntStructPtrMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::IntStructConstPtrMap ##############

package li_std_map::IntStructConstPtrMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_IntStructConstPtrMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::IntStructConstPtrMap_size;
*empty = *li_std_mapc::IntStructConstPtrMap_empty;
*clear = *li_std_mapc::IntStructConstPtrMap_clear;
*get = *li_std_mapc::IntStructConstPtrMap_get;
*set = *li_std_mapc::IntStructConstPtrMap_set;
*del = *li_std_mapc::IntStructConstPtrMap_del;
*has_key = *li_std_mapc::IntStructConstPtrMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_IntStructConstPtrMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::StructPtrIntMap ##############

package li_std_map::StructPtrIntMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_StructPtrIntMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::StructPtrIntMap_size;
*empty = *li_std_mapc::StructPtrIntMap_empty;
*clear = *li_std_mapc::StructPtrIntMap_clear;
*get = *li_std_mapc::StructPtrIntMap_get;
*set = *li_std_mapc::StructPtrIntMap_set;
*del = *li_std_mapc::StructPtrIntMap_del;
*has_key = *li_std_mapc::StructPtrIntMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_StructPtrIntMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::StructIntMap ##############

package li_std_map::StructIntMap;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_StructIntMap(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::StructIntMap_size;
*empty = *li_std_mapc::StructIntMap_empty;
*clear = *li_std_mapc::StructIntMap_clear;
*get = *li_std_mapc::StructIntMap_get;
*set = *li_std_mapc::StructIntMap_set;
*del = *li_std_mapc::StructIntMap_del;
*has_key = *li_std_mapc::StructIntMap_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_StructIntMap($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::A ##############

package li_std_map::A;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
*swig_val_get = *li_std_mapc::A_val_get;
*swig_val_set = *li_std_mapc::A_val_set;
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_A(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_A($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::pairii ##############

package li_std_map::pairii;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_pairii(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *li_std_mapc::pairii_first_get;
*swig_first_set = *li_std_mapc::pairii_first_set;
*swig_second_get = *li_std_mapc::pairii_second_get;
*swig_second_set = *li_std_mapc::pairii_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_pairii($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::pairAA ##############

package li_std_map::pairAA;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_pairAA(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *li_std_mapc::pairAA_first_get;
*swig_first_set = *li_std_mapc::pairAA_first_set;
*swig_second_get = *li_std_mapc::pairAA_second_get;
*swig_second_set = *li_std_mapc::pairAA_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_pairAA($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::pairA ##############

package li_std_map::pairA;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_pairA(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *li_std_mapc::pairA_first_get;
*swig_first_set = *li_std_mapc::pairA_first_set;
*swig_second_get = *li_std_mapc::pairA_second_get;
*swig_second_set = *li_std_mapc::pairA_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_pairA($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::mapA ##############

package li_std_map::mapA;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_mapA(@_);
    bless $self, $pkg if defined($self);
}

*size = *li_std_mapc::mapA_size;
*empty = *li_std_mapc::mapA_empty;
*clear = *li_std_mapc::mapA_clear;
*get = *li_std_mapc::mapA_get;
*set = *li_std_mapc::mapA_set;
*del = *li_std_mapc::mapA_del;
*has_key = *li_std_mapc::mapA_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_mapA($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::paircA1 ##############

package li_std_map::paircA1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_paircA1(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *li_std_mapc::paircA1_first_get;
*swig_first_set = *li_std_mapc::paircA1_first_set;
*swig_second_get = *li_std_mapc::paircA1_second_get;
*swig_second_set = *li_std_mapc::paircA1_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_paircA1($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::paircA2 ##############

package li_std_map::paircA2;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_paircA2(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *li_std_mapc::paircA2_first_get;
*swig_first_set = *li_std_mapc::paircA2_first_set;
*swig_second_get = *li_std_mapc::paircA2_second_get;
*swig_second_set = *li_std_mapc::paircA2_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_paircA2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::pairiiA ##############

package li_std_map::pairiiA;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_pairiiA(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *li_std_mapc::pairiiA_first_get;
*swig_first_set = *li_std_mapc::pairiiA_first_set;
*swig_second_get = *li_std_mapc::pairiiA_second_get;
*swig_second_set = *li_std_mapc::pairiiA_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_pairiiA($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_std_map::pairiiAc ##############

package li_std_map::pairiiAc;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_std_map );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_std_mapc::new_pairiiAc(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *li_std_mapc::pairiiAc_first_get;
*swig_first_set = *li_std_mapc::pairiiAc_first_set;
*swig_second_get = *li_std_mapc::pairiiAc_second_get;
*swig_second_set = *li_std_mapc::pairiiAc_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_std_mapc::delete_pairiiAc($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package li_std_map;

1;
