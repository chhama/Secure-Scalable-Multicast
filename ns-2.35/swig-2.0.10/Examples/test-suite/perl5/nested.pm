# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package nested;
use base qw(Exporter);
use base qw(DynaLoader);
package nestedc;
bootstrap nested;
package nested;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package nested;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package nested;


############# Class : nested::TestStruct ##############

package nested::TestStruct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_a_get = *nestedc::TestStruct_a_get;
*swig_a_set = *nestedc::TestStruct_a_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_TestStruct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_TestStruct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStructNamed ##############

package nested::OuterStructNamed;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_inner_struct_named_get = *nestedc::OuterStructNamed_inner_struct_named_get;
*swig_inner_struct_named_set = *nestedc::OuterStructNamed_inner_struct_named_set;
*swig_inner_union_named_get = *nestedc::OuterStructNamed_inner_union_named_get;
*swig_inner_union_named_set = *nestedc::OuterStructNamed_inner_union_named_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStructNamed(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStructNamed($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStructNamed_inner_union_named ##############

package nested::OuterStructNamed_inner_union_named;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_ee_get = *nestedc::OuterStructNamed_inner_union_named_ee_get;
*swig_ee_set = *nestedc::OuterStructNamed_inner_union_named_ee_set;
*swig_ff_get = *nestedc::OuterStructNamed_inner_union_named_ff_get;
*swig_ff_set = *nestedc::OuterStructNamed_inner_union_named_ff_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStructNamed_inner_union_named(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStructNamed_inner_union_named($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStructNamed_inner_struct_named ##############

package nested::OuterStructNamed_inner_struct_named;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_dd_get = *nestedc::OuterStructNamed_inner_struct_named_dd_get;
*swig_dd_set = *nestedc::OuterStructNamed_inner_struct_named_dd_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStructNamed_inner_struct_named(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStructNamed_inner_struct_named($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStructUnnamed ##############

package nested::OuterStructUnnamed;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_inner_struct_unnamed_get = *nestedc::OuterStructUnnamed_inner_struct_unnamed_get;
*swig_inner_struct_unnamed_set = *nestedc::OuterStructUnnamed_inner_struct_unnamed_set;
*swig_inner_union_unnamed_get = *nestedc::OuterStructUnnamed_inner_union_unnamed_get;
*swig_inner_union_unnamed_set = *nestedc::OuterStructUnnamed_inner_union_unnamed_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStructUnnamed(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStructUnnamed($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStructUnnamed_inner_union_unnamed ##############

package nested::OuterStructUnnamed_inner_union_unnamed;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_yy_get = *nestedc::OuterStructUnnamed_inner_union_unnamed_yy_get;
*swig_yy_set = *nestedc::OuterStructUnnamed_inner_union_unnamed_yy_set;
*swig_zz_get = *nestedc::OuterStructUnnamed_inner_union_unnamed_zz_get;
*swig_zz_set = *nestedc::OuterStructUnnamed_inner_union_unnamed_zz_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStructUnnamed_inner_union_unnamed(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStructUnnamed_inner_union_unnamed($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStructUnnamed_inner_struct_unnamed ##############

package nested::OuterStructUnnamed_inner_struct_unnamed;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_xx_get = *nestedc::OuterStructUnnamed_inner_struct_unnamed_xx_get;
*swig_xx_set = *nestedc::OuterStructUnnamed_inner_struct_unnamed_xx_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStructUnnamed_inner_struct_unnamed(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStructUnnamed_inner_struct_unnamed($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStruct ##############

package nested::OuterStruct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_EmbeddedUnion_get = *nestedc::OuterStruct_EmbeddedUnion_get;
*swig_EmbeddedUnion_set = *nestedc::OuterStruct_EmbeddedUnion_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStruct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStruct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStruct_EmbeddedUnion ##############

package nested::OuterStruct_EmbeddedUnion;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_OuterNestedStruct_get = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_get;
*swig_OuterNestedStruct_set = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStruct_EmbeddedUnion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStruct_EmbeddedUnion($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStruct_EmbeddedUnion_OuterNestedStruct ##############

package nested::OuterStruct_EmbeddedUnion_OuterNestedStruct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_InnerNestedUnion_get = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion_get;
*swig_InnerNestedUnion_set = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion_set;
*swig_InnerNestedStruct_get = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedStruct_get;
*swig_InnerNestedStruct_set = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedStruct_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStruct_EmbeddedUnion_OuterNestedStruct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStruct_EmbeddedUnion_OuterNestedStruct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedStruct ##############

package nested::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedStruct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_blue_get = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedStruct_blue_get;
*swig_blue_set = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedStruct_blue_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedStruct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedStruct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : nested::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion ##############

package nested::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( nested );
%OWNER = ();
%ITERATORS = ();
*swig_red_get = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion_red_get;
*swig_red_set = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion_red_set;
*swig_green_get = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion_green_get;
*swig_green_set = *nestedc::OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion_green_set;
sub new {
    my $pkg = shift;
    my $self = nestedc::new_OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        nestedc::delete_OuterStruct_EmbeddedUnion_OuterNestedStruct_InnerNestedUnion($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package nested;

1;
