# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package li_boost_shared_ptr;
use base qw(Exporter);
use base qw(DynaLoader);
package li_boost_shared_ptrc;
bootstrap li_boost_shared_ptr;
package li_boost_shared_ptr;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package li_boost_shared_ptr;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package li_boost_shared_ptr;

*derivedpointertest = *li_boost_shared_ptrc::derivedpointertest;
*derivedreftest = *li_boost_shared_ptrc::derivedreftest;
*derivedsmartptrtest = *li_boost_shared_ptrc::derivedsmartptrtest;
*derivedsmartptrpointertest = *li_boost_shared_ptrc::derivedsmartptrpointertest;
*derivedsmartptrreftest = *li_boost_shared_ptrc::derivedsmartptrreftest;
*derivedsmartptrpointerreftest = *li_boost_shared_ptrc::derivedsmartptrpointerreftest;
*test3rdupcast = *li_boost_shared_ptrc::test3rdupcast;
*factorycreate = *li_boost_shared_ptrc::factorycreate;
*smartpointertest = *li_boost_shared_ptrc::smartpointertest;
*smartpointerpointertest = *li_boost_shared_ptrc::smartpointerpointertest;
*smartpointerreftest = *li_boost_shared_ptrc::smartpointerreftest;
*smartpointerpointerreftest = *li_boost_shared_ptrc::smartpointerpointerreftest;
*constsmartpointertest = *li_boost_shared_ptrc::constsmartpointertest;
*constsmartpointerpointertest = *li_boost_shared_ptrc::constsmartpointerpointertest;
*constsmartpointerreftest = *li_boost_shared_ptrc::constsmartpointerreftest;
*valuetest = *li_boost_shared_ptrc::valuetest;
*pointertest = *li_boost_shared_ptrc::pointertest;
*reftest = *li_boost_shared_ptrc::reftest;
*pointerreftest = *li_boost_shared_ptrc::pointerreftest;
*nullsmartpointerpointertest = *li_boost_shared_ptrc::nullsmartpointerpointertest;
*pointerownertest = *li_boost_shared_ptrc::pointerownertest;
*smartpointerpointerownertest = *li_boost_shared_ptrc::smartpointerpointerownertest;
*use_count = *li_boost_shared_ptrc::use_count;
*ref_1 = *li_boost_shared_ptrc::ref_1;
*overload_rawbyval = *li_boost_shared_ptrc::overload_rawbyval;
*overload_rawbyref = *li_boost_shared_ptrc::overload_rawbyref;
*overload_rawbyptr = *li_boost_shared_ptrc::overload_rawbyptr;
*overload_rawbyptrref = *li_boost_shared_ptrc::overload_rawbyptrref;
*overload_smartbyval = *li_boost_shared_ptrc::overload_smartbyval;
*overload_smartbyref = *li_boost_shared_ptrc::overload_smartbyref;
*overload_smartbyptr = *li_boost_shared_ptrc::overload_smartbyptr;
*overload_smartbyptrref = *li_boost_shared_ptrc::overload_smartbyptrref;
*pair_id2 = *li_boost_shared_ptrc::pair_id2;
*pair_id1 = *li_boost_shared_ptrc::pair_id1;
*shared_ptr_wrapper_count = *li_boost_shared_ptrc::shared_ptr_wrapper_count;

############# Class : li_boost_shared_ptr::Klass ##############

package li_boost_shared_ptr::Klass;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_boost_shared_ptr );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_boost_shared_ptrc::delete_Klass($self);
        delete $OWNER{$self};
    }
}

*getValue = *li_boost_shared_ptrc::Klass_getValue;
*append = *li_boost_shared_ptrc::Klass_append;
sub new {
    my $pkg = shift;
    my $self = li_boost_shared_ptrc::new_Klass(@_);
    bless $self, $pkg if defined($self);
}

*getTotal_count = *li_boost_shared_ptrc::Klass_getTotal_count;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_boost_shared_ptr::KlassDerived ##############

package li_boost_shared_ptr::KlassDerived;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_boost_shared_ptr::Klass li_boost_shared_ptr );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_boost_shared_ptrc::new_KlassDerived(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_boost_shared_ptrc::delete_KlassDerived($self);
        delete $OWNER{$self};
    }
}

*getValue = *li_boost_shared_ptrc::KlassDerived_getValue;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_boost_shared_ptr::Klass2ndDerived ##############

package li_boost_shared_ptr::Klass2ndDerived;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_boost_shared_ptr::Klass li_boost_shared_ptr );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_boost_shared_ptrc::new_Klass2ndDerived(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_boost_shared_ptrc::delete_Klass2ndDerived($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_boost_shared_ptr::Klass3rdDerived ##############

package li_boost_shared_ptr::Klass3rdDerived;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_boost_shared_ptr::Klass2ndDerived li_boost_shared_ptr );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_boost_shared_ptrc::new_Klass3rdDerived(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_boost_shared_ptrc::delete_Klass3rdDerived($self);
        delete $OWNER{$self};
    }
}

*getValue = *li_boost_shared_ptrc::Klass3rdDerived_getValue;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_boost_shared_ptr::MemberVariables ##############

package li_boost_shared_ptr::MemberVariables;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_boost_shared_ptr );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = li_boost_shared_ptrc::new_MemberVariables(@_);
    bless $self, $pkg if defined($self);
}

*swig_SmartMemberValue_get = *li_boost_shared_ptrc::MemberVariables_SmartMemberValue_get;
*swig_SmartMemberValue_set = *li_boost_shared_ptrc::MemberVariables_SmartMemberValue_set;
*swig_SmartMemberPointer_get = *li_boost_shared_ptrc::MemberVariables_SmartMemberPointer_get;
*swig_SmartMemberPointer_set = *li_boost_shared_ptrc::MemberVariables_SmartMemberPointer_set;
*swig_SmartMemberReference_get = *li_boost_shared_ptrc::MemberVariables_SmartMemberReference_get;
*swig_SmartMemberReference_set = *li_boost_shared_ptrc::MemberVariables_SmartMemberReference_set;
*swig_MemberValue_get = *li_boost_shared_ptrc::MemberVariables_MemberValue_get;
*swig_MemberValue_set = *li_boost_shared_ptrc::MemberVariables_MemberValue_set;
*swig_MemberPointer_get = *li_boost_shared_ptrc::MemberVariables_MemberPointer_get;
*swig_MemberPointer_set = *li_boost_shared_ptrc::MemberVariables_MemberPointer_set;
*swig_MemberReference_get = *li_boost_shared_ptrc::MemberVariables_MemberReference_get;
*swig_MemberReference_set = *li_boost_shared_ptrc::MemberVariables_MemberReference_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_boost_shared_ptrc::delete_MemberVariables($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_boost_shared_ptr::BaseIntDouble ##############

package li_boost_shared_ptr::BaseIntDouble;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_boost_shared_ptr );
%OWNER = ();
%ITERATORS = ();
*swig_klassBase_get = *li_boost_shared_ptrc::BaseIntDouble_klassBase_get;
*swig_klassBase_set = *li_boost_shared_ptrc::BaseIntDouble_klassBase_set;
*swig_baseVal1_get = *li_boost_shared_ptrc::BaseIntDouble_baseVal1_get;
*swig_baseVal1_set = *li_boost_shared_ptrc::BaseIntDouble_baseVal1_set;
*swig_baseVal2_get = *li_boost_shared_ptrc::BaseIntDouble_baseVal2_get;
*swig_baseVal2_set = *li_boost_shared_ptrc::BaseIntDouble_baseVal2_set;
sub new {
    my $pkg = shift;
    my $self = li_boost_shared_ptrc::new_BaseIntDouble(@_);
    bless $self, $pkg if defined($self);
}

*getValue = *li_boost_shared_ptrc::BaseIntDouble_getValue;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_boost_shared_ptrc::delete_BaseIntDouble($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : li_boost_shared_ptr::PairIntDouble ##############

package li_boost_shared_ptr::PairIntDouble;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( li_boost_shared_ptr::BaseIntDouble li_boost_shared_ptr );
%OWNER = ();
%ITERATORS = ();
*swig_klassPair_get = *li_boost_shared_ptrc::PairIntDouble_klassPair_get;
*swig_klassPair_set = *li_boost_shared_ptrc::PairIntDouble_klassPair_set;
*swig_val1_get = *li_boost_shared_ptrc::PairIntDouble_val1_get;
*swig_val1_set = *li_boost_shared_ptrc::PairIntDouble_val1_set;
*swig_val2_get = *li_boost_shared_ptrc::PairIntDouble_val2_get;
*swig_val2_set = *li_boost_shared_ptrc::PairIntDouble_val2_set;
sub new {
    my $pkg = shift;
    my $self = li_boost_shared_ptrc::new_PairIntDouble(@_);
    bless $self, $pkg if defined($self);
}

*getValue = *li_boost_shared_ptrc::PairIntDouble_getValue;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        li_boost_shared_ptrc::delete_PairIntDouble($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package li_boost_shared_ptr;

*debug_shared = *li_boost_shared_ptrc::debug_shared;
*GlobalSmartValue = *li_boost_shared_ptrc::GlobalSmartValue;

my %__GlobalValue_hash;
tie %__GlobalValue_hash,"li_boost_shared_ptr::Klass", $li_boost_shared_ptrc::GlobalValue;
$GlobalValue= \%__GlobalValue_hash;
bless $GlobalValue, li_boost_shared_ptr::Klass;

my %__GlobalPointer_hash;
tie %__GlobalPointer_hash,"li_boost_shared_ptr::Klass", $li_boost_shared_ptrc::GlobalPointer;
$GlobalPointer= \%__GlobalPointer_hash;
bless $GlobalPointer, li_boost_shared_ptr::Klass;

my %__GlobalReference_hash;
tie %__GlobalReference_hash,"li_boost_shared_ptr::Klass", $li_boost_shared_ptrc::GlobalReference;
$GlobalReference= \%__GlobalReference_hash;
bless $GlobalReference, li_boost_shared_ptr::Klass;
*NOT_COUNTING = *li_boost_shared_ptrc::NOT_COUNTING;
1;
