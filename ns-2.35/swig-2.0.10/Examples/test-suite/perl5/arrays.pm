# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package arrays;
use base qw(Exporter);
use base qw(DynaLoader);
package arraysc;
bootstrap arrays;
package arrays;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package arrays;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package arrays;

*fn_taking_arrays = *arraysc::fn_taking_arrays;
*newintpointer = *arraysc::newintpointer;
*setintfrompointer = *arraysc::setintfrompointer;
*getintfrompointer = *arraysc::getintfrompointer;
*array_pointer_func = *arraysc::array_pointer_func;

############# Class : arrays::SimpleStruct ##############

package arrays::SimpleStruct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( arrays );
%OWNER = ();
%ITERATORS = ();
*swig_double_field_get = *arraysc::SimpleStruct_double_field_get;
*swig_double_field_set = *arraysc::SimpleStruct_double_field_set;
sub new {
    my $pkg = shift;
    my $self = arraysc::new_SimpleStruct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        arraysc::delete_SimpleStruct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : arrays::ArrayStruct ##############

package arrays::ArrayStruct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( arrays );
%OWNER = ();
%ITERATORS = ();
*swig_array_c_get = *arraysc::ArrayStruct_array_c_get;
*swig_array_c_set = *arraysc::ArrayStruct_array_c_set;
*swig_array_sc_get = *arraysc::ArrayStruct_array_sc_get;
*swig_array_sc_set = *arraysc::ArrayStruct_array_sc_set;
*swig_array_uc_get = *arraysc::ArrayStruct_array_uc_get;
*swig_array_uc_set = *arraysc::ArrayStruct_array_uc_set;
*swig_array_s_get = *arraysc::ArrayStruct_array_s_get;
*swig_array_s_set = *arraysc::ArrayStruct_array_s_set;
*swig_array_us_get = *arraysc::ArrayStruct_array_us_get;
*swig_array_us_set = *arraysc::ArrayStruct_array_us_set;
*swig_array_i_get = *arraysc::ArrayStruct_array_i_get;
*swig_array_i_set = *arraysc::ArrayStruct_array_i_set;
*swig_array_ui_get = *arraysc::ArrayStruct_array_ui_get;
*swig_array_ui_set = *arraysc::ArrayStruct_array_ui_set;
*swig_array_l_get = *arraysc::ArrayStruct_array_l_get;
*swig_array_l_set = *arraysc::ArrayStruct_array_l_set;
*swig_array_ul_get = *arraysc::ArrayStruct_array_ul_get;
*swig_array_ul_set = *arraysc::ArrayStruct_array_ul_set;
*swig_array_ll_get = *arraysc::ArrayStruct_array_ll_get;
*swig_array_ll_set = *arraysc::ArrayStruct_array_ll_set;
*swig_array_f_get = *arraysc::ArrayStruct_array_f_get;
*swig_array_f_set = *arraysc::ArrayStruct_array_f_set;
*swig_array_d_get = *arraysc::ArrayStruct_array_d_get;
*swig_array_d_set = *arraysc::ArrayStruct_array_d_set;
*swig_array_struct_get = *arraysc::ArrayStruct_array_struct_get;
*swig_array_struct_set = *arraysc::ArrayStruct_array_struct_set;
*swig_array_structpointers_get = *arraysc::ArrayStruct_array_structpointers_get;
*swig_array_structpointers_set = *arraysc::ArrayStruct_array_structpointers_set;
*swig_array_ipointers_get = *arraysc::ArrayStruct_array_ipointers_get;
*swig_array_ipointers_set = *arraysc::ArrayStruct_array_ipointers_set;
*swig_array_enum_get = *arraysc::ArrayStruct_array_enum_get;
*swig_array_enum_set = *arraysc::ArrayStruct_array_enum_set;
*swig_array_enumpointers_get = *arraysc::ArrayStruct_array_enumpointers_get;
*swig_array_enumpointers_set = *arraysc::ArrayStruct_array_enumpointers_set;
*swig_array_const_i_get = *arraysc::ArrayStruct_array_const_i_get;
*swig_array_const_i_set = *arraysc::ArrayStruct_array_const_i_set;
sub new {
    my $pkg = shift;
    my $self = arraysc::new_ArrayStruct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        arraysc::delete_ArrayStruct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : arrays::CartPoseData_t ##############

package arrays::CartPoseData_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( arrays );
%OWNER = ();
%ITERATORS = ();
*swig_p_get = *arraysc::CartPoseData_t_p_get;
*swig_p_set = *arraysc::CartPoseData_t_p_set;
sub new {
    my $pkg = shift;
    my $self = arraysc::new_CartPoseData_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        arraysc::delete_CartPoseData_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package arrays;

*ARRAY_LEN = *arraysc::ARRAY_LEN;
*One = *arraysc::One;
*Two = *arraysc::Two;
*Three = *arraysc::Three;
*Four = *arraysc::Four;
*Five = *arraysc::Five;
1;
