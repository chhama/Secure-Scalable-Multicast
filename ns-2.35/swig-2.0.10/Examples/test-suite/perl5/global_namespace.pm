# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package global_namespace;
use base qw(Exporter);
use base qw(DynaLoader);
package global_namespacec;
bootstrap global_namespace;
package global_namespace;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package global_namespace;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package global_namespace;

*getKlass1A = *global_namespacec::getKlass1A;
*getKlass1B = *global_namespacec::getKlass1B;
*getKlass2A = *global_namespacec::getKlass2A;
*getKlass2B = *global_namespacec::getKlass2B;
*getKlass3A = *global_namespacec::getKlass3A;
*getKlass3B = *global_namespacec::getKlass3B;
*getKlass4A = *global_namespacec::getKlass4A;
*getKlass4B = *global_namespacec::getKlass4B;
*getKlass5A = *global_namespacec::getKlass5A;
*getKlass5B = *global_namespacec::getKlass5B;
*getKlass6A = *global_namespacec::getKlass6A;
*getKlass6B = *global_namespacec::getKlass6B;
*getKlass7A = *global_namespacec::getKlass7A;
*getKlass7B = *global_namespacec::getKlass7B;

############# Class : global_namespace::Klass1 ##############

package global_namespace::Klass1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_Klass1(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_Klass1($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::Klass2 ##############

package global_namespace::Klass2;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_Klass2(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_Klass2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::Klass3 ##############

package global_namespace::Klass3;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_Klass3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_Klass3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::Klass4 ##############

package global_namespace::Klass4;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_Klass4(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_Klass4($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::Klass5 ##############

package global_namespace::Klass5;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_Klass5(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_Klass5($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::Klass6 ##############

package global_namespace::Klass6;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_Klass6(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_Klass6($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::Klass7 ##############

package global_namespace::Klass7;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_Klass7(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_Klass7($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::KlassMethods ##############

package global_namespace::KlassMethods;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
*methodA = *global_namespacec::KlassMethods_methodA;
*methodB = *global_namespacec::KlassMethods_methodB;
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_KlassMethods(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_KlassMethods($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::XYZ1 ##############

package global_namespace::XYZ1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_XYZ1(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_XYZ1($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::XYZ2 ##############

package global_namespace::XYZ2;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_XYZ2(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_XYZ2($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::XYZ3 ##############

package global_namespace::XYZ3;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_XYZ3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_XYZ3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::XYZ4 ##############

package global_namespace::XYZ4;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_XYZ4(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_XYZ4($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::XYZ5 ##############

package global_namespace::XYZ5;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_XYZ5(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_XYZ5($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::XYZ6 ##############

package global_namespace::XYZ6;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_XYZ6(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_XYZ6($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::XYZ7 ##############

package global_namespace::XYZ7;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_XYZ7(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_XYZ7($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::XYZMethods ##############

package global_namespace::XYZMethods;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
*methodA = *global_namespacec::XYZMethods_methodA;
*methodB = *global_namespacec::XYZMethods_methodB;
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_XYZMethods(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_XYZMethods($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::AnEnumMethods ##############

package global_namespace::AnEnumMethods;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
*methodA = *global_namespacec::AnEnumMethods_methodA;
*methodB = *global_namespacec::AnEnumMethods_methodB;
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_AnEnumMethods(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_AnEnumMethods($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : global_namespace::TheEnumMethods ##############

package global_namespace::TheEnumMethods;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( global_namespace );
%OWNER = ();
%ITERATORS = ();
*methodA = *global_namespacec::TheEnumMethods_methodA;
*methodB = *global_namespacec::TheEnumMethods_methodB;
sub new {
    my $pkg = shift;
    my $self = global_namespacec::new_TheEnumMethods(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        global_namespacec::delete_TheEnumMethods($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package global_namespace;

*anenum1 = *global_namespacec::anenum1;
*anenum2 = *global_namespacec::anenum2;
*anenum3 = *global_namespacec::anenum3;
*theenum1 = *global_namespacec::theenum1;
*theenum2 = *global_namespacec::theenum2;
*theenum3 = *global_namespacec::theenum3;
1;
