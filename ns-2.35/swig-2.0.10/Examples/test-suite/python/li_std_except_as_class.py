# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_li_std_except_as_class', [dirname(__file__)])
        except ImportError:
            import _li_std_except_as_class
            return _li_std_except_as_class
        if fp is not None:
            try:
                _mod = imp.load_module('_li_std_except_as_class', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _li_std_except_as_class = swig_import_helper()
    del swig_import_helper
else:
    import _li_std_except_as_class
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class exception(Exception):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, exception, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, exception, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _li_std_except_as_class.delete_exception
    __del__ = lambda self : None;
    def what(self): return _li_std_except_as_class.exception_what(self)
    def __init__(self): 
        this = _li_std_except_as_class.new_exception()
        try: self.this.append(this)
        except: self.this = this
exception_swigregister = _li_std_except_as_class.exception_swigregister
exception_swigregister(exception)

class bad_exception(exception):
    __swig_setmethods__ = {}
    for _s in [exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, bad_exception, name, value)
    __swig_getmethods__ = {}
    for _s in [exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, bad_exception, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _li_std_except_as_class.new_bad_exception()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_bad_exception
    __del__ = lambda self : None;
bad_exception_swigregister = _li_std_except_as_class.bad_exception_swigregister
bad_exception_swigregister(bad_exception)

class logic_error(exception):
    __swig_setmethods__ = {}
    for _s in [exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, logic_error, name, value)
    __swig_getmethods__ = {}
    for _s in [exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, logic_error, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_logic_error(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_logic_error
    __del__ = lambda self : None;
logic_error_swigregister = _li_std_except_as_class.logic_error_swigregister
logic_error_swigregister(logic_error)

class domain_error(logic_error):
    __swig_setmethods__ = {}
    for _s in [logic_error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, domain_error, name, value)
    __swig_getmethods__ = {}
    for _s in [logic_error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, domain_error, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_domain_error(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_domain_error
    __del__ = lambda self : None;
domain_error_swigregister = _li_std_except_as_class.domain_error_swigregister
domain_error_swigregister(domain_error)

class invalid_argument(logic_error):
    __swig_setmethods__ = {}
    for _s in [logic_error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, invalid_argument, name, value)
    __swig_getmethods__ = {}
    for _s in [logic_error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, invalid_argument, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_invalid_argument(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_invalid_argument
    __del__ = lambda self : None;
invalid_argument_swigregister = _li_std_except_as_class.invalid_argument_swigregister
invalid_argument_swigregister(invalid_argument)

class length_error(logic_error):
    __swig_setmethods__ = {}
    for _s in [logic_error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, length_error, name, value)
    __swig_getmethods__ = {}
    for _s in [logic_error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, length_error, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_length_error(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_length_error
    __del__ = lambda self : None;
length_error_swigregister = _li_std_except_as_class.length_error_swigregister
length_error_swigregister(length_error)

class out_of_range(logic_error):
    __swig_setmethods__ = {}
    for _s in [logic_error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, out_of_range, name, value)
    __swig_getmethods__ = {}
    for _s in [logic_error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, out_of_range, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_out_of_range(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_out_of_range
    __del__ = lambda self : None;
out_of_range_swigregister = _li_std_except_as_class.out_of_range_swigregister
out_of_range_swigregister(out_of_range)

class runtime_error(exception):
    __swig_setmethods__ = {}
    for _s in [exception]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, runtime_error, name, value)
    __swig_getmethods__ = {}
    for _s in [exception]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, runtime_error, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_runtime_error(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_runtime_error
    __del__ = lambda self : None;
runtime_error_swigregister = _li_std_except_as_class.runtime_error_swigregister
runtime_error_swigregister(runtime_error)

class range_error(runtime_error):
    __swig_setmethods__ = {}
    for _s in [runtime_error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, range_error, name, value)
    __swig_getmethods__ = {}
    for _s in [runtime_error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, range_error, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_range_error(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_range_error
    __del__ = lambda self : None;
range_error_swigregister = _li_std_except_as_class.range_error_swigregister
range_error_swigregister(range_error)

class overflow_error(runtime_error):
    __swig_setmethods__ = {}
    for _s in [runtime_error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, overflow_error, name, value)
    __swig_getmethods__ = {}
    for _s in [runtime_error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, overflow_error, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_overflow_error(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_overflow_error
    __del__ = lambda self : None;
overflow_error_swigregister = _li_std_except_as_class.overflow_error_swigregister
overflow_error_swigregister(overflow_error)

class underflow_error(runtime_error):
    __swig_setmethods__ = {}
    for _s in [runtime_error]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, underflow_error, name, value)
    __swig_getmethods__ = {}
    for _s in [runtime_error]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, underflow_error, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _li_std_except_as_class.new_underflow_error(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _li_std_except_as_class.delete_underflow_error
    __del__ = lambda self : None;
underflow_error_swigregister = _li_std_except_as_class.underflow_error_swigregister
underflow_error_swigregister(underflow_error)


def test_domain_error():
  return _li_std_except_as_class.test_domain_error()
test_domain_error = _li_std_except_as_class.test_domain_error
# This file is compatible with both classic and new-style classes.


