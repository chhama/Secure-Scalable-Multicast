<?php

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.10
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

// Try to load our extension if it's not already loaded.
if (!extension_loaded('li_std_vector')) {
  if (strtolower(substr(PHP_OS, 0, 3)) === 'win') {
    if (!dl('php_li_std_vector.dll')) return;
  } else {
    // PHP_SHLIB_SUFFIX gives 'dylib' on MacOS X but modules are 'so'.
    if (PHP_SHLIB_SUFFIX === 'dylib') {
      if (!dl('li_std_vector.so')) return;
    } else {
      if (!dl('li_std_vector.'.PHP_SHLIB_SUFFIX)) return;
    }
  }
}



abstract class li_std_vector {
	static function typedef_test($s) {
		return typedef_test($s);
	}

	static function average($v) {
		return average($v);
	}

	static function half($v) {
		$r=half($v);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new RealVector($r);
		}
		return $r;
	}

	static function halve_in_place($v) {
		halve_in_place($v);
	}

	static function vecreal($vec) {
		$r=vecreal($vec);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new RealVector($r);
		}
		return $r;
	}

	static function vecintptr($vec) {
		$r=vecintptr($vec);
		if (!is_resource($r)) return $r;
		switch (get_resource_type($r)) {
		case '_p_std__vectorT_int_p_t': return new IntPtrVector($r);
		default: return new IntVector($r);
		}
	}

	static function vecintconstptr($vec) {
		$r=vecintconstptr($vec);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new IntConstPtrVector($r);
		}
		return $r;
	}

	static function vecstruct($vec) {
		$r=vecstruct($vec);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new StructVector($r);
		}
		return $r;
	}

	static function vecstructptr($vec) {
		$r=vecstructptr($vec);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new StructPtrVector($r);
		}
		return $r;
	}

	static function vecstructconstptr($vec) {
		$r=vecstructconstptr($vec);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new StructConstPtrVector($r);
		}
		return $r;
	}
}

/* PHP Proxy Classes */
class IntVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_int_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_IntVector(); break;
		default: $this->_cPtr=new_IntVector($n);
		}
	}

	function size() {
		return IntVector_size($this->_cPtr);
	}

	function capacity() {
		return IntVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		IntVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		IntVector_clear($this->_cPtr);
	}

	function push($x) {
		IntVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return IntVector_is_empty($this->_cPtr);
	}

	function pop() {
		return IntVector_pop($this->_cPtr);
	}

	function get($i) {
		return IntVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		IntVector_set($this->_cPtr,$i,$val);
	}
}

class BoolVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_bool_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_BoolVector(); break;
		default: $this->_cPtr=new_BoolVector($n);
		}
	}

	function size() {
		return BoolVector_size($this->_cPtr);
	}

	function capacity() {
		return BoolVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		BoolVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		BoolVector_clear($this->_cPtr);
	}

	function push($x) {
		BoolVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return BoolVector_is_empty($this->_cPtr);
	}

	function pop() {
		return BoolVector_pop($this->_cPtr);
	}

	function get($i) {
		return BoolVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		BoolVector_set($this->_cPtr,$i,$val);
	}
}

class CharVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_char_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_CharVector(); break;
		default: $this->_cPtr=new_CharVector($n);
		}
	}

	function size() {
		return CharVector_size($this->_cPtr);
	}

	function capacity() {
		return CharVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		CharVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		CharVector_clear($this->_cPtr);
	}

	function push($x) {
		CharVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return CharVector_is_empty($this->_cPtr);
	}

	function pop() {
		return CharVector_pop($this->_cPtr);
	}

	function get($i) {
		return CharVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		CharVector_set($this->_cPtr,$i,$val);
	}
}

class ShortVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_short_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_ShortVector(); break;
		default: $this->_cPtr=new_ShortVector($n);
		}
	}

	function size() {
		return ShortVector_size($this->_cPtr);
	}

	function capacity() {
		return ShortVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		ShortVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		ShortVector_clear($this->_cPtr);
	}

	function push($x) {
		ShortVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return ShortVector_is_empty($this->_cPtr);
	}

	function pop() {
		return ShortVector_pop($this->_cPtr);
	}

	function get($i) {
		return ShortVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		ShortVector_set($this->_cPtr,$i,$val);
	}
}

class LongVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_long_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_LongVector(); break;
		default: $this->_cPtr=new_LongVector($n);
		}
	}

	function size() {
		return LongVector_size($this->_cPtr);
	}

	function capacity() {
		return LongVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		LongVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		LongVector_clear($this->_cPtr);
	}

	function push($x) {
		LongVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return LongVector_is_empty($this->_cPtr);
	}

	function pop() {
		return LongVector_pop($this->_cPtr);
	}

	function get($i) {
		return LongVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		LongVector_set($this->_cPtr,$i,$val);
	}
}

class UCharVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_unsigned_char_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_UCharVector(); break;
		default: $this->_cPtr=new_UCharVector($n);
		}
	}

	function size() {
		return UCharVector_size($this->_cPtr);
	}

	function capacity() {
		return UCharVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		UCharVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		UCharVector_clear($this->_cPtr);
	}

	function push($x) {
		UCharVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return UCharVector_is_empty($this->_cPtr);
	}

	function pop() {
		return UCharVector_pop($this->_cPtr);
	}

	function get($i) {
		return UCharVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		UCharVector_set($this->_cPtr,$i,$val);
	}
}

class UIntVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_unsigned_int_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_UIntVector(); break;
		default: $this->_cPtr=new_UIntVector($n);
		}
	}

	function size() {
		return UIntVector_size($this->_cPtr);
	}

	function capacity() {
		return UIntVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		UIntVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		UIntVector_clear($this->_cPtr);
	}

	function push($x) {
		UIntVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return UIntVector_is_empty($this->_cPtr);
	}

	function pop() {
		return UIntVector_pop($this->_cPtr);
	}

	function get($i) {
		return UIntVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		UIntVector_set($this->_cPtr,$i,$val);
	}
}

class UShortVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_unsigned_short_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_UShortVector(); break;
		default: $this->_cPtr=new_UShortVector($n);
		}
	}

	function size() {
		return UShortVector_size($this->_cPtr);
	}

	function capacity() {
		return UShortVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		UShortVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		UShortVector_clear($this->_cPtr);
	}

	function push($x) {
		UShortVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return UShortVector_is_empty($this->_cPtr);
	}

	function pop() {
		return UShortVector_pop($this->_cPtr);
	}

	function get($i) {
		return UShortVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		UShortVector_set($this->_cPtr,$i,$val);
	}
}

class ULongVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_unsigned_long_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_ULongVector(); break;
		default: $this->_cPtr=new_ULongVector($n);
		}
	}

	function size() {
		return ULongVector_size($this->_cPtr);
	}

	function capacity() {
		return ULongVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		ULongVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		ULongVector_clear($this->_cPtr);
	}

	function push($x) {
		ULongVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return ULongVector_is_empty($this->_cPtr);
	}

	function pop() {
		return ULongVector_pop($this->_cPtr);
	}

	function get($i) {
		return ULongVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		ULongVector_set($this->_cPtr,$i,$val);
	}
}

class DoubleVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_double_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_DoubleVector(); break;
		default: $this->_cPtr=new_DoubleVector($n);
		}
	}

	function size() {
		return DoubleVector_size($this->_cPtr);
	}

	function capacity() {
		return DoubleVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		DoubleVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		DoubleVector_clear($this->_cPtr);
	}

	function push($x) {
		DoubleVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return DoubleVector_is_empty($this->_cPtr);
	}

	function pop() {
		return DoubleVector_pop($this->_cPtr);
	}

	function get($i) {
		return DoubleVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		DoubleVector_set($this->_cPtr,$i,$val);
	}
}

class StringVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_std__string_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_StringVector(); break;
		default: $this->_cPtr=new_StringVector($n);
		}
	}

	function size() {
		return StringVector_size($this->_cPtr);
	}

	function capacity() {
		return StringVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		StringVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		StringVector_clear($this->_cPtr);
	}

	function push($x) {
		StringVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return StringVector_is_empty($this->_cPtr);
	}

	function pop() {
		return StringVector_pop($this->_cPtr);
	}

	function get($i) {
		return StringVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		StringVector_set($this->_cPtr,$i,$val);
	}
}

class RealVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_float_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_RealVector(); break;
		default: $this->_cPtr=new_RealVector($n);
		}
	}

	function size() {
		return RealVector_size($this->_cPtr);
	}

	function capacity() {
		return RealVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		RealVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		RealVector_clear($this->_cPtr);
	}

	function push($x) {
		RealVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return RealVector_is_empty($this->_cPtr);
	}

	function pop() {
		return RealVector_pop($this->_cPtr);
	}

	function get($i) {
		return RealVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		RealVector_set($this->_cPtr,$i,$val);
	}
}

class Struct {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'num') return Struct_num_set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if (function_exists('Struct_'.$var.'_set')) return true;
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'num') return Struct_num_get($this->_cPtr);
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($d=null) {
		if (is_resource($d) && get_resource_type($d) === '_p_Struct') {
			$this->_cPtr=$d;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_Struct(); break;
		default: $this->_cPtr=new_Struct($d);
		}
	}
}

class Structure {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'num') return Structure_num_set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if (function_exists('Structure_'.$var.'_set')) return true;
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'num') return Structure_num_get($this->_cPtr);
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($d=null) {
		if (is_resource($d) && get_resource_type($d) === '_p_Structure') {
			$this->_cPtr=$d;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_Structure(); break;
		default: $this->_cPtr=new_Structure($d);
		}
	}
}

class IntPtrVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_int_p_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_IntPtrVector(); break;
		default: $this->_cPtr=new_IntPtrVector($n);
		}
	}

	function size() {
		return IntPtrVector_size($this->_cPtr);
	}

	function capacity() {
		return IntPtrVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		IntPtrVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		IntPtrVector_clear($this->_cPtr);
	}

	function push($x) {
		IntPtrVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return IntPtrVector_is_empty($this->_cPtr);
	}

	function pop() {
		return IntPtrVector_pop($this->_cPtr);
	}

	function get($i) {
		return IntPtrVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		IntPtrVector_set($this->_cPtr,$i,$val);
	}
}

class IntConstPtrVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_int_const_p_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_IntConstPtrVector(); break;
		default: $this->_cPtr=new_IntConstPtrVector($n);
		}
	}

	function size() {
		return IntConstPtrVector_size($this->_cPtr);
	}

	function capacity() {
		return IntConstPtrVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		IntConstPtrVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		IntConstPtrVector_clear($this->_cPtr);
	}

	function push($x) {
		IntConstPtrVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return IntConstPtrVector_is_empty($this->_cPtr);
	}

	function pop() {
		return IntConstPtrVector_pop($this->_cPtr);
	}

	function get($i) {
		return IntConstPtrVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		IntConstPtrVector_set($this->_cPtr,$i,$val);
	}
}

class StructVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_Struct_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_StructVector(); break;
		default: $this->_cPtr=new_StructVector($n);
		}
	}

	function size() {
		return StructVector_size($this->_cPtr);
	}

	function capacity() {
		return StructVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		StructVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		StructVector_clear($this->_cPtr);
	}

	function push($x) {
		StructVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return StructVector_is_empty($this->_cPtr);
	}

	function pop() {
		$r=StructVector_pop($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new Struct($r);
		}
		return $r;
	}

	function get($i) {
		$r=StructVector_get($this->_cPtr,$i);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new Struct($r);
		}
		return $r;
	}

	function set($i,$val) {
		StructVector_set($this->_cPtr,$i,$val);
	}
}

class StructPtrVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_Struct_p_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_StructPtrVector(); break;
		default: $this->_cPtr=new_StructPtrVector($n);
		}
	}

	function size() {
		return StructPtrVector_size($this->_cPtr);
	}

	function capacity() {
		return StructPtrVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		StructPtrVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		StructPtrVector_clear($this->_cPtr);
	}

	function push($x) {
		StructPtrVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return StructPtrVector_is_empty($this->_cPtr);
	}

	function pop() {
		$r=StructPtrVector_pop($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new Struct($r);
		}
		return $r;
	}

	function get($i) {
		$r=StructPtrVector_get($this->_cPtr,$i);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new Struct($r);
		}
		return $r;
	}

	function set($i,$val) {
		StructPtrVector_set($this->_cPtr,$i,$val);
	}
}

class StructConstPtrVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_Struct_const_p_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_StructConstPtrVector(); break;
		default: $this->_cPtr=new_StructConstPtrVector($n);
		}
	}

	function size() {
		return StructConstPtrVector_size($this->_cPtr);
	}

	function capacity() {
		return StructConstPtrVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		StructConstPtrVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		StructConstPtrVector_clear($this->_cPtr);
	}

	function push($x) {
		StructConstPtrVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return StructConstPtrVector_is_empty($this->_cPtr);
	}

	function pop() {
		$r=StructConstPtrVector_pop($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new Struct($r);
		}
		return $r;
	}

	function get($i) {
		$r=StructConstPtrVector_get($this->_cPtr,$i);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new Struct($r);
		}
		return $r;
	}

	function set($i,$val) {
		StructConstPtrVector_set($this->_cPtr,$i,$val);
	}
}

class MyClass {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_MyClass') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_MyClass();
	}
}

class MyClassPtrVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_MyClass_p_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_MyClassPtrVector(); break;
		default: $this->_cPtr=new_MyClassPtrVector($n);
		}
	}

	function size() {
		return MyClassPtrVector_size($this->_cPtr);
	}

	function capacity() {
		return MyClassPtrVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		MyClassPtrVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		MyClassPtrVector_clear($this->_cPtr);
	}

	function push($x) {
		MyClassPtrVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return MyClassPtrVector_is_empty($this->_cPtr);
	}

	function pop() {
		$r=MyClassPtrVector_pop($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new MyClass($r);
		}
		return $r;
	}

	function get($i) {
		$r=MyClassPtrVector_get($this->_cPtr,$i);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new MyClass($r);
		}
		return $r;
	}

	function set($i,$val) {
		MyClassPtrVector_set($this->_cPtr,$i,$val);
	}
}

class RetsMetadata {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_li_std_vector_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_li_std_vector_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function GetAllResources($n) {
		$r=RetsMetadata_GetAllResources($this->_cPtr,$n);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (class_exists($c)) return new $c($r);
			return new MyClassPtrVector($r);
		}
		return $r;
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_RetsMetadata') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_RetsMetadata();
	}
}


?>
